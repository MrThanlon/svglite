/* automatically generated by rust-bindgen 0.63.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VGLITE_RELEASE_VERSION: u32 = 2101248;
pub const VGLITE_HEADER_VERSION: u32 = 6;
pub const VGLITE_VERSION_2_0: u32 = 1;
pub const VLC_OP_END: u32 = 0;
pub const VLC_OP_CLOSE: u32 = 1;
pub const VLC_OP_MOVE: u32 = 2;
pub const VLC_OP_MOVE_REL: u32 = 3;
pub const VLC_OP_LINE: u32 = 4;
pub const VLC_OP_LINE_REL: u32 = 5;
pub const VLC_OP_QUAD: u32 = 6;
pub const VLC_OP_QUAD_REL: u32 = 7;
pub const VLC_OP_CUBIC: u32 = 8;
pub const VLC_OP_CUBIC_REL: u32 = 9;
pub const VLC_OP_SCCWARC: u32 = 10;
pub const VLC_OP_SCCWARC_REL: u32 = 11;
pub const VLC_OP_SCWARC: u32 = 12;
pub const VLC_OP_SCWARC_REL: u32 = 13;
pub const VLC_OP_LCCWARC: u32 = 14;
pub const VLC_OP_LCCWARC_REL: u32 = 15;
pub const VLC_OP_LCWARC: u32 = 16;
pub const VLC_OP_LCWARC_REL: u32 = 17;
pub const VG_LITE_ERROR: u32 = 1;
pub const VLC_MAX_GRAD: u32 = 16;
pub const VLC_GRADBUFFER_WIDTH: u32 = 256;
pub const MAX_COLOR_RAMP_STOPS: u32 = 256;
pub const vgliteDUMP_PATH: &[u8; 3usize] = b"./\0";
pub const vgliteDUMP_KEY: &[u8; 8usize] = b"process\0";
pub const DUMP_CAPTURE: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const vg_lite_error_VG_LITE_SUCCESS: vg_lite_error = 0;
#[doc = " Success."]
pub const vg_lite_error_VG_LITE_INVALID_ARGUMENT: vg_lite_error = 1;
#[doc = " An invalid argument was specified."]
pub const vg_lite_error_VG_LITE_OUT_OF_MEMORY: vg_lite_error = 2;
#[doc = " Out of memory."]
pub const vg_lite_error_VG_LITE_NO_CONTEXT: vg_lite_error = 3;
#[doc = " No context or an unintialized context specified."]
pub const vg_lite_error_VG_LITE_TIMEOUT: vg_lite_error = 4;
#[doc = " A timeout has occured during a wait."]
pub const vg_lite_error_VG_LITE_OUT_OF_RESOURCES: vg_lite_error = 5;
#[doc = " Out of system resources."]
pub const vg_lite_error_VG_LITE_GENERIC_IO: vg_lite_error = 6;
#[doc = " Cannot communicate with the kernel driver."]
pub const vg_lite_error_VG_LITE_NOT_SUPPORT: vg_lite_error = 7;
#[doc = " Function call not supported."]
pub const vg_lite_error_VG_LITE_ALREADY_EXISTS: vg_lite_error = 8;
#[doc = " Object already exists"]
pub const vg_lite_error_VG_LITE_NOT_ALIGNED: vg_lite_error = 9;
#[doc = " Data alignment error"]
pub const vg_lite_error_VG_LITE_FLEXA_TIME_OUT: vg_lite_error = 10;
#[doc = " VG timeout requesting for segment buffer"]
pub const vg_lite_error_VG_LITE_FLEXA_HANDSHAKE_FAIL: vg_lite_error = 11;
#[doc = "@abstract Error codes that the vg_lite functions can return.\n\n@discussion\nAll API functions return a status code. On success, <code>VG_LITE_SUCCESS</code> will be returned when a function is\nsuccessful. This value is set to zero, so if any function returns a non-zero value, an error has occured."]
pub type vg_lite_error = ::std::os::raw::c_uint;
#[doc = "@abstract Error codes that the vg_lite functions can return.\n\n@discussion\nAll API functions return a status code. On success, <code>VG_LITE_SUCCESS</code> will be returned when a function is\nsuccessful. This value is set to zero, so if any function returns a non-zero value, an error has occured."]
pub use self::vg_lite_error as vg_lite_error_t;
#[doc = "@abstract The floating point type used by the VGLite API."]
pub type vg_lite_float_t = f32;
#[doc = "@abstract A 32-bit color value used by the VGLite API.\n\n@discussion\nThe color value specifies the color used in various functions. The color is formed using 8-bit RGBA channels. The red channel\nis in the lower 8-bit of the color value, followed by the green and blue channels. The alpha channel is in the upper 8-bit of\nthe color value.\n\nFor L8 target formats, the RGB color is converted to L8 by using the default ITU-R BT.709 conversion rules."]
pub type vg_lite_color_t = u32;
pub const vg_lite_quality_VG_LITE_HIGH: vg_lite_quality = 0;
#[doc = " High quality 16x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_UPPER: vg_lite_quality = 1;
#[doc = " Upper quality 8x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_MEDIUM: vg_lite_quality = 2;
#[doc = " Medium quality 4x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_LOW: vg_lite_quality = 3;
#[doc = "@abstract Quality enumeration for a given path.\n\n@discussion\nEach path should specify a quality hint for the hardware. The path generation tool will generate the quality hint based on the\ncomplexity of the path."]
pub type vg_lite_quality = ::std::os::raw::c_uint;
#[doc = "@abstract Quality enumeration for a given path.\n\n@discussion\nEach path should specify a quality hint for the hardware. The path generation tool will generate the quality hint based on the\ncomplexity of the path."]
pub use self::vg_lite_quality as vg_lite_quality_t;
pub const vg_lite_format_VG_LITE_S8: vg_lite_format = 0;
#[doc = " Signed 8-bit coordinates."]
pub const vg_lite_format_VG_LITE_S16: vg_lite_format = 1;
#[doc = " Signed 16-bit coordinates."]
pub const vg_lite_format_VG_LITE_S32: vg_lite_format = 2;
#[doc = " Signed 32-bit coordinates."]
pub const vg_lite_format_VG_LITE_FP32: vg_lite_format = 3;
#[doc = "@abstract Format of path coordinates.\n\n@discussion\nEach path can have a separate coordinate system. The path generation tool will find the most optimal coordinate system for any\ngiven path based on its dimensions and input coordinates."]
pub type vg_lite_format = ::std::os::raw::c_uint;
#[doc = "@abstract Format of path coordinates.\n\n@discussion\nEach path can have a separate coordinate system. The path generation tool will find the most optimal coordinate system for any\ngiven path based on its dimensions and input coordinates."]
pub use self::vg_lite_format as vg_lite_format_t;
pub const vg_lite_buffer_format_VG_LITE_RGBA8888: vg_lite_buffer_format = 0;
#[doc = " 32-bit RGBA format with 8 bits per color channel. Red is in bits 7:0, green in bits 15:8, blue in\nbits 23:16, and the alpha channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_BGRA8888: vg_lite_buffer_format = 1;
#[doc = " 32-bit RGBA format with 8 bits per color channel. Red is in bits 23:16, green in bits 15:8, blue in\nbits 7:0, and the alpha channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_RGBX8888: vg_lite_buffer_format = 2;
#[doc = " 32-bit RGBX format with 8 bits per color channel. Red is in bits 7:0, green in bits 15:8, blue in\nbits 23:16, and the x channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_BGRX8888: vg_lite_buffer_format = 3;
#[doc = " 32-bit RGBX format with 8 bits per color channel. Red is in bits 23:16, green in bits 15:8, blue in\nbits 7:0, and the x channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_RGB565: vg_lite_buffer_format = 4;
#[doc = " 16-bit RGB format with 5 and 6 bits per color channel. Red is in bits 4:0, green in bits 10:5, and\nthe blue color channel is in bits 15:11."]
pub const vg_lite_buffer_format_VG_LITE_BGR565: vg_lite_buffer_format = 5;
#[doc = " 16-bit RGB format with 5 and 6 bits per color channel. Red is in bits 15:11, green in bits 10:5,\nand the blue color channel is in bits 4:0."]
pub const vg_lite_buffer_format_VG_LITE_RGBA4444: vg_lite_buffer_format = 6;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Red is in bits 3:0, green in bits 7:4, blue in\nbits 11:8 and the alpha channel is in bits 15:12."]
pub const vg_lite_buffer_format_VG_LITE_BGRA4444: vg_lite_buffer_format = 7;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Red is in bits 11:8, green in bits 7:4, blue in\nbits 3:0 and the alpha channel is in bits 15:12."]
pub const vg_lite_buffer_format_VG_LITE_BGRA5551: vg_lite_buffer_format = 8;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Red is in bits 14:10, green in bits 9:5, blue in\nbits 4:0 and the alpha channel is in bit 15:15."]
pub const vg_lite_buffer_format_VG_LITE_A4: vg_lite_buffer_format = 9;
#[doc = " 4-bit alpha format. There are no RGB values."]
pub const vg_lite_buffer_format_VG_LITE_A8: vg_lite_buffer_format = 10;
#[doc = " 8-bit alpha format. There are no RGB values."]
pub const vg_lite_buffer_format_VG_LITE_L8: vg_lite_buffer_format = 11;
#[doc = " 8-bit luminance value. There is no alpha value."]
pub const vg_lite_buffer_format_VG_LITE_YUYV: vg_lite_buffer_format = 12;
#[doc = " Packed YUV format, 32-bit for 2 pixels. Y0 is in bits 7:0 and V is in bits 31:23."]
pub const vg_lite_buffer_format_VG_LITE_YUY2: vg_lite_buffer_format = 13;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_NV12: vg_lite_buffer_format = 14;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_ANV12: vg_lite_buffer_format = 15;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_AYUY2: vg_lite_buffer_format = 16;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_YV12: vg_lite_buffer_format = 17;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_YV24: vg_lite_buffer_format = 18;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_YV16: vg_lite_buffer_format = 19;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_NV16: vg_lite_buffer_format = 20;
#[doc = " New formats."]
pub const vg_lite_buffer_format_VG_LITE_YUY2_TILED: vg_lite_buffer_format = 21;
#[doc = " Tiled YUV formats."]
pub const vg_lite_buffer_format_VG_LITE_NV12_TILED: vg_lite_buffer_format = 22;
#[doc = " Tiled YUV formats."]
pub const vg_lite_buffer_format_VG_LITE_ANV12_TILED: vg_lite_buffer_format = 23;
#[doc = " Tiled YUV formats."]
pub const vg_lite_buffer_format_VG_LITE_AYUY2_TILED: vg_lite_buffer_format = 24;
#[doc = " Tiled YUV formats."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_1: vg_lite_buffer_format = 100;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_2: vg_lite_buffer_format = 101;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_4: vg_lite_buffer_format = 102;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_8: vg_lite_buffer_format = 103;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_RGBA2222: vg_lite_buffer_format = 104;
#[doc = " 8-bit RGBA format with 2 bits per color channel.Red is in bits 1:0,green in bits 3:2,blue in\nbits 5:4 and the alpha channel is in bits 7:6"]
pub const vg_lite_buffer_format_VG_LITE_BGRA2222: vg_lite_buffer_format = 105;
#[doc = " 8-bit RGBA format with 2 bits per color channel.Blue is in bits 1:0,green in bits 3:2,red in\nbits 5:4 and the alpha channel is in bits 7:6"]
pub const vg_lite_buffer_format_VG_LITE_ABGR2222: vg_lite_buffer_format = 106;
#[doc = " 8-bit RGBA format with 2 bits per color channel.Alpha is in bits 1:0,blue in bits 3:2,green in\nbits 5:4 and the red channel is in bits 7:6"]
pub const vg_lite_buffer_format_VG_LITE_ARGB2222: vg_lite_buffer_format = 107;
#[doc = " 8-bit RGBA format with 2 bits per color channel.Alpha is in bits 1:0,red in bits 3:2,green in\nbits 5:4 and the blue channel is in bits 7:6"]
pub const vg_lite_buffer_format_VG_LITE_ABGR4444: vg_lite_buffer_format = 108;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Alpha is in bits 3:0, blue in bits 7:4, green in\nbits 11:8 and the red channel is in bits 15:12."]
pub const vg_lite_buffer_format_VG_LITE_ARGB4444: vg_lite_buffer_format = 109;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Alpha is in bits 3:0, red in bits 7:4, green in\nbits 11:8 and the blue channel is in bits 15:12."]
pub const vg_lite_buffer_format_VG_LITE_ABGR8888: vg_lite_buffer_format = 110;
#[doc = " 32-bit RGBA format with 8 bits per color channel. Alpha is in bits 7:0, blue in bits 15:8, green in\nbits 23:16, and the red channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_ARGB8888: vg_lite_buffer_format = 111;
#[doc = " 32-bit RGBA format with 8 bits per color channel. Alpha is in bits 7:0, red in bits 15:8, green in\nbits 23:16, and the blue channel is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_ABGR1555: vg_lite_buffer_format = 112;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Red is in bits 15:11, green in bits 10:6, blue in\nbits 5:1 and the alpha channel is in bit 0:0."]
pub const vg_lite_buffer_format_VG_LITE_RGBA5551: vg_lite_buffer_format = 113;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Blue is in bits 14:10, green in bits 9:5, red in\nbits 4:0 and the alpha channel is in bit 15:15."]
pub const vg_lite_buffer_format_VG_LITE_ARGB1555: vg_lite_buffer_format = 114;
#[doc = " 16-bit RGBA format with 4 bits per color channel. Blue is in bits 15:11, green in bits 10:6, red in\nbits 5:1 and the alpha channel is in bit 0:0."]
pub const vg_lite_buffer_format_VG_LITE_XBGR8888: vg_lite_buffer_format = 115;
#[doc = " 32-bit RGBX format with 8 bits per color channel. X channel is in bits 7:0, blue in bits 15:8, green in\nbits 23:16, and the red is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_XRGB8888: vg_lite_buffer_format = 116;
#[doc = " 32-bit RGBX format with 8 bits per color channel. X channel is in bits 7:0, red in bits 15:8, green in\nbits 23:16, and the blue is in bits 31:24."]
pub const vg_lite_buffer_format_VG_LITE_RGBA8888_ETC2_EAC: vg_lite_buffer_format = 117;
#[doc = " ETC2 format."]
pub const vg_lite_buffer_format_VG_LITE_RGB888: vg_lite_buffer_format = 118;
#[doc = " 24-bit RGB format with 8 bits per color channel. Red is in bits 7:0, green in bits 15:8, blue in\nbits 23:16."]
pub const vg_lite_buffer_format_VG_LITE_BGR888: vg_lite_buffer_format = 119;
#[doc = " 24-bit RGB format with 8 bits per color channel. Blue is in bits 7:0, green in bits 15:8, red in\nbits 23:16."]
pub const vg_lite_buffer_format_VG_LITE_ABGR8565: vg_lite_buffer_format = 120;
#[doc = " 24-bit RGBA format with 4 and 5 bits per color channel. Alpha channel is in bit 7:0, blue in bits 12:8, green in\nbits 18:13 and the red in bits 23:19."]
pub const vg_lite_buffer_format_VG_LITE_BGRA5658: vg_lite_buffer_format = 121;
#[doc = " 24-bit RGBA format with 4 and 5 bits per color channel. Blue is in bits 4:0, green in bits 10:5, red in\nbits 15:11,alpha channel is in bit 23:16."]
pub const vg_lite_buffer_format_VG_LITE_ARGB8565: vg_lite_buffer_format = 122;
#[doc = " 24-bit RGBA format with 4 and 5 bits per color channel. Alpha channel is in bits 7:0, red in bits 12:8, green in\nbits 18:13, and the blue channel is in bits 23:19."]
pub const vg_lite_buffer_format_VG_LITE_RGBA5658: vg_lite_buffer_format = 123;
#[doc = "@abstract Format of a buffer.\n\n@discussion\nThe pixel type for a <code>vg_lite_buffer_t</code> structure."]
pub type vg_lite_buffer_format = ::std::os::raw::c_uint;
#[doc = "@abstract Format of a buffer.\n\n@discussion\nThe pixel type for a <code>vg_lite_buffer_t</code> structure."]
pub use self::vg_lite_buffer_format as vg_lite_buffer_format_t;
pub const vg_lite_swizzle_VG_LITE_SWIZZLE_UV: vg_lite_swizzle = 0;
pub const vg_lite_swizzle_VG_LITE_SWIZZLE_VU: vg_lite_swizzle = 1;
#[doc = "@abstract Swizzle of packed YUV format UV channels.\n\n@discussion\nThe swizzle of packed YUV format UV channels."]
pub type vg_lite_swizzle = ::std::os::raw::c_uint;
#[doc = "@abstract Swizzle of packed YUV format UV channels.\n\n@discussion\nThe swizzle of packed YUV format UV channels."]
pub use self::vg_lite_swizzle as vg_lite_swizzle_t;
pub const vg_lite_yuv2rgb_VG_LITE_YUV601: vg_lite_yuv2rgb = 0;
pub const vg_lite_yuv2rgb_VG_LITE_YUV709: vg_lite_yuv2rgb = 1;
#[doc = "@abstract The YUV<->RGB conversion rule.\n\n@discussion\nIndicate the rule how to convert rgb and yuv colors."]
pub type vg_lite_yuv2rgb = ::std::os::raw::c_uint;
#[doc = "@abstract The YUV<->RGB conversion rule.\n\n@discussion\nIndicate the rule how to convert rgb and yuv colors."]
pub use self::vg_lite_yuv2rgb as vg_lite_yuv2rgb_t;
pub const vg_lite_buffer_layout_VG_LITE_LINEAR: vg_lite_buffer_layout = 0;
pub const vg_lite_buffer_layout_VG_LITE_TILED: vg_lite_buffer_layout = 1;
#[doc = "@abstract The pixel layout in a buffer.\n\n@discussion\nPixels in a buffer may be tiled  or linear."]
pub type vg_lite_buffer_layout = ::std::os::raw::c_uint;
#[doc = "@abstract The pixel layout in a buffer.\n\n@discussion\nPixels in a buffer may be tiled  or linear."]
pub use self::vg_lite_buffer_layout as vg_lite_buffer_layout_t;
pub const vg_lite_buffer_image_mode_VG_LITE_NORMAL_IMAGE_MODE: vg_lite_buffer_image_mode = 0;
pub const vg_lite_buffer_image_mode_VG_LITE_NONE_IMAGE_MODE: vg_lite_buffer_image_mode = 1;
pub const vg_lite_buffer_image_mode_VG_LITE_MULTIPLY_IMAGE_MODE: vg_lite_buffer_image_mode = 2;
#[doc = "@abstract The image (buffer) rendering mode.\n\n@discussion\nThis defines how an image are rendered onto a buffer. There are 3 modes."]
pub type vg_lite_buffer_image_mode = ::std::os::raw::c_uint;
#[doc = "@abstract The image (buffer) rendering mode.\n\n@discussion\nThis defines how an image are rendered onto a buffer. There are 3 modes."]
pub use self::vg_lite_buffer_image_mode as vg_lite_buffer_image_mode_t;
pub const vg_lite_buffer_transparency_mode_VG_LITE_IMAGE_OPAQUE: vg_lite_buffer_transparency_mode =
    0;
pub const vg_lite_buffer_transparency_mode_VG_LITE_IMAGE_TRANSPARENT:
    vg_lite_buffer_transparency_mode = 1;
#[doc = "@abstract The image (buffer) transparency mode.\nOPAQUE, All image pixels are copied to the VGPE for rasterization;\nTRANSPARENT,Only the non-transparent image pixels are copied to the VGPE.\nNote: This mode is valid when IMAGE_MODE(vg_lite_buffer_image_mode_t) isn't NONE."]
pub type vg_lite_buffer_transparency_mode = ::std::os::raw::c_uint;
#[doc = "@abstract The image (buffer) transparency mode.\nOPAQUE, All image pixels are copied to the VGPE for rasterization;\nTRANSPARENT,Only the non-transparent image pixels are copied to the VGPE.\nNote: This mode is valid when IMAGE_MODE(vg_lite_buffer_image_mode_t) isn't NONE."]
pub use self::vg_lite_buffer_transparency_mode as vg_lite_buffer_transparency_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_yuvinfo {
    pub swizzle: vg_lite_swizzle_t,
    pub yuv2rgb: vg_lite_yuv2rgb_t,
    pub uv_planar: u32,
    pub v_planar: u32,
    pub alpha_planar: u32,
    pub uv_stride: u32,
    pub v_stride: u32,
    pub alpha_stride: u32,
    pub uv_height: u32,
    pub v_height: u32,
    pub uv_memory: *mut ::std::os::raw::c_void,
    pub v_memory: *mut ::std::os::raw::c_void,
    pub uv_handle: *mut ::std::os::raw::c_void,
    pub v_handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vg_lite_yuvinfo() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_yuvinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_yuvinfo>(),
        72usize,
        concat!("Size of: ", stringify!(vg_lite_yuvinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_yuvinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_yuvinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swizzle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(swizzle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv2rgb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(yuv2rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_planar) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_planar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_planar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(alpha_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_stride) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_stride) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_stride) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(alpha_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_height) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_memory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_memory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_handle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_handle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_handle)
        )
    );
}
pub type vg_lite_yuvinfo_t = vg_lite_yuvinfo;
pub const vg_lite_blend_VG_LITE_BLEND_NONE: vg_lite_blend = 0;
#[doc = " S, i.e. no blending."]
pub const vg_lite_blend_VG_LITE_BLEND_SRC_OVER: vg_lite_blend = 1;
#[doc = " S + (1 - Sa) * D"]
pub const vg_lite_blend_VG_LITE_BLEND_DST_OVER: vg_lite_blend = 2;
#[doc = " (1 - Da) * S + D"]
pub const vg_lite_blend_VG_LITE_BLEND_SRC_IN: vg_lite_blend = 3;
#[doc = " Da * S"]
pub const vg_lite_blend_VG_LITE_BLEND_DST_IN: vg_lite_blend = 4;
#[doc = " Sa * D"]
pub const vg_lite_blend_VG_LITE_BLEND_SCREEN: vg_lite_blend = 5;
#[doc = " S + D - S * D"]
pub const vg_lite_blend_VG_LITE_BLEND_MULTIPLY: vg_lite_blend = 6;
#[doc = " S * (1 - Da) + D * (1 - Sa) + S * D"]
pub const vg_lite_blend_VG_LITE_BLEND_ADDITIVE: vg_lite_blend = 7;
#[doc = " S + D"]
pub const vg_lite_blend_VG_LITE_BLEND_SUBTRACT: vg_lite_blend = 8;
#[doc = "@abstract Blending modes.\n\n@discussion\nSome of the VGLite API functions calls support blending. S and D represent source and destination color channels and Sa and Da\nrepresent the source and destination alpha channels."]
pub type vg_lite_blend = ::std::os::raw::c_uint;
#[doc = "@abstract Blending modes.\n\n@discussion\nSome of the VGLite API functions calls support blending. S and D represent source and destination color channels and Sa and Da\nrepresent the source and destination alpha channels."]
pub use self::vg_lite_blend as vg_lite_blend_t;
pub const vg_lite_fill_VG_LITE_FILL_NON_ZERO: vg_lite_fill = 0;
#[doc = " Non-zero fill rule. A pixel is drawn if it crosses at least one path pixel."]
pub const vg_lite_fill_VG_LITE_FILL_EVEN_ODD: vg_lite_fill = 1;
#[doc = "@abstract Fill rules.\n\n@discussion\nFor drawing any path, the hardware supports both non-zero and odd-even fill rules.\n\nTo determine whether any point is contained inside an object, imagine drawing a line from that point out to infinity in any\ndirection such that the line does not cross any vertex of the path. For each edge that is crossed by the line, add 1 to the\ncounter if the edge crosses from left to right, as seen by an observer walking across the line towards infinity, and subtract 1\nif the edge crosses from right to left. In this way, each region of the plane will receive an integer value.\n\nThe non-zero fill rule says that a point is inside the shape if the resulting sum is not equal to zero. The even/odd rule says\nthat a point is inside the shape if the resulting sum is odd, regardless of sign."]
pub type vg_lite_fill = ::std::os::raw::c_uint;
#[doc = "@abstract Fill rules.\n\n@discussion\nFor drawing any path, the hardware supports both non-zero and odd-even fill rules.\n\nTo determine whether any point is contained inside an object, imagine drawing a line from that point out to infinity in any\ndirection such that the line does not cross any vertex of the path. For each edge that is crossed by the line, add 1 to the\ncounter if the edge crosses from left to right, as seen by an observer walking across the line towards infinity, and subtract 1\nif the edge crosses from right to left. In this way, each region of the plane will receive an integer value.\n\nThe non-zero fill rule says that a point is inside the shape if the resulting sum is not equal to zero. The even/odd rule says\nthat a point is inside the shape if the resulting sum is odd, regardless of sign."]
pub use self::vg_lite_fill as vg_lite_fill_t;
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_INDEX_FORMAT: vg_lite_feature = 0;
pub const vg_lite_feature_gcFEATURE_BIT_VG_PE_PREMULTIPLY: vg_lite_feature = 1;
pub const vg_lite_feature_gcFEATURE_BIT_VG_SCISSOR: vg_lite_feature = 2;
pub const vg_lite_feature_gcFEATURE_BIT_VG_BORDER_CULLING: vg_lite_feature = 3;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RGBA2_FORMAT: vg_lite_feature = 4;
pub const vg_lite_feature_gcFEATURE_BIT_VG_QUALITY_8X: vg_lite_feature = 5;
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_FASTCLAER: vg_lite_feature = 6;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RADIAL_GRADIENT: vg_lite_feature = 7;
pub const vg_lite_feature_gcFEATURE_BIT_VG_GLOBAL_ALPHA: vg_lite_feature = 8;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RGBA8_ETC2_EAC: vg_lite_feature = 9;
pub const vg_lite_feature_gcFEATURE_BIT_VG_COLOR_KEY: vg_lite_feature = 10;
pub const vg_lite_feature_gcFEATURE_BIT_VG_DOUBLE_IMAGE: vg_lite_feature = 11;
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUV_OUTPUT: vg_lite_feature = 12;
pub const vg_lite_feature_gcFEATURE_BIT_VG_FLEXA: vg_lite_feature = 13;
pub const vg_lite_feature_gcFEATURE_BIT_VG_24BIT: vg_lite_feature = 14;
pub const vg_lite_feature_gcFEATURE_BIT_VG_DITHER: vg_lite_feature = 15;
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUV_INPUT: vg_lite_feature = 16;
pub const vg_lite_feature_gcFEATURE_BIT_VG_USE_DST: vg_lite_feature = 17;
pub const vg_lite_feature_gcFEATURE_BIT_VG_PE_CLEAR: vg_lite_feature = 18;
pub const vg_lite_feature_gcFEATURE_COUNT: vg_lite_feature = 19;
pub type vg_lite_feature = ::std::os::raw::c_uint;
pub use self::vg_lite_feature as vg_lite_feature_t;
pub const vg_lite_global_alpha_VG_LITE_NORMAL: vg_lite_global_alpha = 0;
pub const vg_lite_global_alpha_VG_LITE_GLOBAL: vg_lite_global_alpha = 1;
pub const vg_lite_global_alpha_VG_LITE_SCALED: vg_lite_global_alpha = 2;
pub type vg_lite_global_alpha = ::std::os::raw::c_uint;
pub use self::vg_lite_global_alpha as vg_lite_global_alpha_t;
pub const vg_lite_filter_VG_LITE_FILTER_POINT: vg_lite_filter = 0;
pub const vg_lite_filter_VG_LITE_FILTER_LINEAR: vg_lite_filter = 65536;
pub const vg_lite_filter_VG_LITE_FILTER_BI_LINEAR: vg_lite_filter = 131072;
pub type vg_lite_filter = ::std::os::raw::c_uint;
pub use self::vg_lite_filter as vg_lite_filter_t;
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_COLOR: vg_lite_pattern_mode = 0;
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_PAD: vg_lite_pattern_mode = 1;
pub type vg_lite_pattern_mode = ::std::os::raw::c_uint;
pub use self::vg_lite_pattern_mode as vg_lite_pattern_mode_t;
pub const vg_lite_radial_gradient_spreadmode_t_VG_LITE_RADIAL_GRADIENT_SPREAD_FILL:
    vg_lite_radial_gradient_spreadmode_t = 0;
pub const vg_lite_radial_gradient_spreadmode_t_VG_LITE_RADIAL_GRADIENT_SPREAD_PAD:
    vg_lite_radial_gradient_spreadmode_t = 1;
pub const vg_lite_radial_gradient_spreadmode_t_VG_LITE_RADIAL_GRADIENT_SPREAD_REPEAT:
    vg_lite_radial_gradient_spreadmode_t = 2;
pub const vg_lite_radial_gradient_spreadmode_t_VG_LITE_RADIAL_GRADIENT_SPREAD_REFLECT:
    vg_lite_radial_gradient_spreadmode_t = 3;
pub type vg_lite_radial_gradient_spreadmode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_info {
    pub api_version: u32,
    #[doc = " VGLite API version."]
    pub header_version: u32,
    #[doc = " VGLite API header version."]
    pub release_version: u32,
    #[doc = " VGLite release version."]
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_vg_lite_info() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_info>(),
        16usize,
        concat!("Size of: ", stringify!(vg_lite_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(header_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(release_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(reserved)
        )
    );
}
pub type vg_lite_info_t = vg_lite_info;
#[doc = "@abstract A 3x3 matrix.\n\n@discussion\nFor those functions that need a matrix, this is the structure that defines it. The contents are a simple 3x3 matrix\nconsisting of floating pointer numbers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_matrix {
    pub m: [[vg_lite_float_t; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_vg_lite_matrix() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_matrix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_matrix>(),
        36usize,
        concat!("Size of: ", stringify!(vg_lite_matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_matrix),
            "::",
            stringify!(m)
        )
    );
}
#[doc = "@abstract A 3x3 matrix.\n\n@discussion\nFor those functions that need a matrix, this is the structure that defines it. The contents are a simple 3x3 matrix\nconsisting of floating pointer numbers."]
pub type vg_lite_matrix_t = vg_lite_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_fc_buffer {
    pub width: i32,
    #[doc = " Width of the buffer in pixels."]
    pub height: i32,
    #[doc = " height of the buffer in pixels."]
    pub stride: i32,
    #[doc = " The number of bytes to move from one line in the buffer to the next line."]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " The memory handle of the buffer's memory as allocated by the VGLite kernel."]
    pub memory: *mut ::std::os::raw::c_void,
    #[doc = " The logical pointer to the buffer's memory for the CPU."]
    pub address: u32,
    #[doc = " The address to the buffer's memory for the hardware."]
    pub color: u32,
}
#[test]
fn bindgen_test_layout_vg_lite_fc_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_fc_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_fc_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_fc_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_fc_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_fc_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(color)
        )
    );
}
pub type vg_lite_fc_buffer_t = vg_lite_fc_buffer;
#[doc = "@abstract A wrapper structure for any image or render target.\n\n@discussion\nEach piece of memory, whether it is an image used as a source or a buffer used as a target, requires a structure to define it.\nThis structure contains all the information the VGLite API requires to access the buffer's memory by the hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_buffer {
    pub width: i32,
    #[doc = " Width of the buffer in pixels."]
    pub height: i32,
    #[doc = " Height of the buffer in pixels."]
    pub stride: i32,
    #[doc = " The number of bytes to move from one line in the buffer to the next line."]
    pub tiled: vg_lite_buffer_layout_t,
    #[doc = " Indicating the buffer memory layout is linear or tiled."]
    pub format: vg_lite_buffer_format_t,
    #[doc = " The pixel format of the buffer."]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " The memory handle of the buffer's memory as allocated by the VGLite kernel."]
    pub memory: *mut ::std::os::raw::c_void,
    #[doc = " The logical pointer to the buffer's memory for the CPU."]
    pub address: u32,
    #[doc = " The address to the buffer's memory for the hardware."]
    pub yuv: vg_lite_yuvinfo_t,
    #[doc = " The yuv format details."]
    pub image_mode: vg_lite_buffer_image_mode_t,
    #[doc = " The blit image mode."]
    pub transparency_mode: vg_lite_buffer_transparency_mode_t,
    pub fc_enable: i8,
    #[doc = " 1 to enable im fastclear;\n0 to disable im fastclear."]
    pub fc_buffer: [vg_lite_fc_buffer_t; 3usize],
}
#[test]
fn bindgen_test_layout_vg_lite_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_buffer>(),
        256usize,
        concat!("Size of: ", stringify!(vg_lite_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(tiled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(yuv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_mode) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(image_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transparency_mode) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(transparency_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc_enable) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(fc_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc_buffer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(fc_buffer)
        )
    );
}
#[doc = "@abstract A wrapper structure for any image or render target.\n\n@discussion\nEach piece of memory, whether it is an image used as a source or a buffer used as a target, requires a structure to define it.\nThis structure contains all the information the VGLite API requires to access the buffer's memory by the hardware."]
pub type vg_lite_buffer_t = vg_lite_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_hw_memory {
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " gpu memory object handle."]
    pub memory: *mut ::std::os::raw::c_void,
    #[doc = " logical memory address."]
    pub address: u32,
    #[doc = " GPU memory address."]
    pub bytes: u32,
    #[doc = " Size of memory."]
    pub property: u32,
}
#[test]
fn bindgen_test_layout_vg_lite_hw_memory() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_hw_memory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_hw_memory>(),
        32usize,
        concat!("Size of: ", stringify!(vg_lite_hw_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_hw_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_hw_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(property)
        )
    );
}
pub type vg_lite_hw_memory_t = vg_lite_hw_memory;
#[doc = "@abstract A path used by the drawing command.\n\n@discussion\nEach path needs a few parameters. This structure defines those parameters, so the VGLite driver knows the detail of a path."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_path {
    pub bounding_box: [vg_lite_float_t; 4usize],
    #[doc = " Bounding box specified as left, top, right, and bottom."]
    pub quality: vg_lite_quality_t,
    #[doc = " Quality hint for the path."]
    pub format: vg_lite_format_t,
    #[doc = " Coordinate format."]
    pub uploaded: vg_lite_hw_memory_t,
    #[doc = " Path data that has been upload into GPU addressable memory."]
    pub path_length: i32,
    #[doc = " Number of bytes in the path data."]
    pub path: *mut ::std::os::raw::c_void,
    #[doc = " Pointer to the physical description of the path."]
    pub path_changed: i8,
    pub pdata_internal: i8,
}
#[test]
fn bindgen_test_layout_vg_lite_path() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_path> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_path>(),
        80usize,
        concat!("Size of: ", stringify!(vg_lite_path))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_path>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_path))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounding_box) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(bounding_box)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uploaded) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(uploaded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_length) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_changed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdata_internal) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(pdata_internal)
        )
    );
}
#[doc = "@abstract A path used by the drawing command.\n\n@discussion\nEach path needs a few parameters. This structure defines those parameters, so the VGLite driver knows the detail of a path."]
pub type vg_lite_path_t = vg_lite_path;
#[doc = "@abstract A rectangle.\n\n@discussion\nA rectangle defines a rectangular definition of the screen."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_rectangle {
    pub x: i32,
    #[doc = " Left coordinate of the rectangle."]
    pub y: i32,
    #[doc = " Top coordinate of the rectangle."]
    pub width: i32,
    #[doc = " Width of the rectangle."]
    pub height: i32,
}
#[test]
fn bindgen_test_layout_vg_lite_rectangle() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_rectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(vg_lite_rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_rectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "@abstract A rectangle.\n\n@discussion\nA rectangle defines a rectangular definition of the screen."]
pub type vg_lite_rectangle_t = vg_lite_rectangle;
#[doc = "@abstract Tessellation buffer information.\n\n@discussion\nThe tessellation buffer information for access."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_tsbuffer_info {
    pub tessellation_buffer_gpu: u32,
    #[doc = " HW physical address."]
    pub tessellation_buffer_logic: *mut u8,
    #[doc = " Logical address."]
    pub tessellation_buffer_size: u32,
    #[doc = " Buffer size for tessellation buffer"]
    pub vg_count_buffer_size: u32,
    #[doc = " Buffer size for VG count buffer"]
    pub tessellation_width_height: u32,
    #[doc = " Combination of buffer width and height."]
    pub tessellation_origin: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_vg_lite_tsbuffer_info() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_tsbuffer_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_tsbuffer_info>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_tsbuffer_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_tsbuffer_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_tsbuffer_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tessellation_buffer_gpu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(tessellation_buffer_gpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tessellation_buffer_logic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(tessellation_buffer_logic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tessellation_buffer_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(tessellation_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vg_count_buffer_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(vg_count_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tessellation_width_height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(tessellation_width_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tessellation_origin) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_tsbuffer_info),
            "::",
            stringify!(tessellation_origin)
        )
    );
}
#[doc = "@abstract Tessellation buffer information.\n\n@discussion\nThe tessellation buffer information for access."]
pub type vg_lite_tsbuffer_info_t = vg_lite_tsbuffer_info;
#[doc = "@abstract Linear gradient definition.\n\n@discussion\nLinear gradient is applied to filling a path. It will generate a 256x1 image according the settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_linear_gradient {
    pub colors: [u32; 16usize],
    #[doc = " Colors for stops."]
    pub count: u32,
    #[doc = " Count of colors, up to 16."]
    pub stops: [u32; 16usize],
    #[doc = " Color stops, value from 0 to 255."]
    pub matrix: vg_lite_matrix_t,
    #[doc = " The matrix to transform the gradient."]
    pub image: vg_lite_buffer_t,
}
#[test]
fn bindgen_test_layout_vg_lite_linear_gradient() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_linear_gradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_linear_gradient>(),
        424usize,
        concat!("Size of: ", stringify!(vg_lite_linear_gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_linear_gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_linear_gradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stops) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(stops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(image)
        )
    );
}
#[doc = "@abstract Linear gradient definition.\n\n@discussion\nLinear gradient is applied to filling a path. It will generate a 256x1 image according the settings."]
pub type vg_lite_linear_gradient_t = vg_lite_linear_gradient;
#[doc = "@abstract color ramp definition.\n\n@discussion\nThis is the stop for the radial gradient.The number of parameters is 5,and give the offset and\ncolor of the stop.Each stop is defined by a floating-point offset value and four floating-point values\ncontaining the sRGBA color and alpha value associated with each stop, in the form of a non-premultiplied\n(R, G, B, alpha) quad.And the range of all parameters in it is [0,1].[0,1] of the color channel value is\nmapped to [0,255]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_color_ramp {
    pub stop: vg_lite_float_t,
    pub red: vg_lite_float_t,
    pub green: vg_lite_float_t,
    pub blue: vg_lite_float_t,
    pub alpha: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_color_ramp() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_color_ramp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_color_ramp>(),
        20usize,
        concat!("Size of: ", stringify!(vg_lite_color_ramp))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_color_ramp>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_color_ramp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = "@abstract color ramp definition.\n\n@discussion\nThis is the stop for the radial gradient.The number of parameters is 5,and give the offset and\ncolor of the stop.Each stop is defined by a floating-point offset value and four floating-point values\ncontaining the sRGBA color and alpha value associated with each stop, in the form of a non-premultiplied\n(R, G, B, alpha) quad.And the range of all parameters in it is [0,1].[0,1] of the color channel value is\nmapped to [0,255]."]
pub type vg_lite_color_ramp_t = vg_lite_color_ramp;
#[doc = "@abstract color ramp definition.\n\n@discussion\nThis is the stop for the radial gradient.The number of parameters is 5,and give the offset and\ncolor of the stop.Each stop is defined by a floating-point offset value and four floating-point values\ncontaining the sRGBA color and alpha value associated with each stop, in the form of a non-premultiplied\n(R, G, B, alpha) quad.And the range of all parameters in it is [0,1].[0,1] of the color channel value is\nmapped to [0,255]."]
pub type vg_lite_color_ramp_ptr = *mut vg_lite_color_ramp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_radial_gradient_parameter {
    pub cx: vg_lite_float_t,
    pub cy: vg_lite_float_t,
    pub r: vg_lite_float_t,
    pub fx: vg_lite_float_t,
    pub fy: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_radial_gradient_parameter() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_radial_gradient_parameter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_radial_gradient_parameter>(),
        20usize,
        concat!("Size of: ", stringify!(vg_lite_radial_gradient_parameter))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_radial_gradient_parameter>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vg_lite_radial_gradient_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(fy)
        )
    );
}
pub type vg_lite_radial_gradient_parameter_t = vg_lite_radial_gradient_parameter;
#[doc = "@abstract radial gradient definition.\n\n@discussion\nradial gradient is applied to filling a path."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_radial_gradient {
    pub count: u32,
    #[doc = " Count of colors, up to 256."]
    pub matrix: vg_lite_matrix_t,
    #[doc = " The matrix to transform the gradient."]
    pub image: vg_lite_buffer_t,
    #[doc = " The image for rendering as gradient pattern."]
    pub radialGradient: vg_lite_radial_gradient_parameter_t,
    pub vgColorRampLength: u32,
    pub vgColorRamp: [vg_lite_color_ramp_t; 256usize],
    pub intColorRampLength: u32,
    pub intColorRamp: [vg_lite_color_ramp_t; 258usize],
    pub colorRampPremultiplied: u8,
    pub SpreadMode: vg_lite_radial_gradient_spreadmode_t,
}
#[test]
fn bindgen_test_layout_vg_lite_radial_gradient() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_radial_gradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_radial_gradient>(),
        10616usize,
        concat!("Size of: ", stringify!(vg_lite_radial_gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_radial_gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_radial_gradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radialGradient) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(radialGradient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vgColorRampLength) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(vgColorRampLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vgColorRamp) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(vgColorRamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intColorRampLength) as usize - ptr as usize },
        5440usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(intColorRampLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intColorRamp) as usize - ptr as usize },
        5444usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(intColorRamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorRampPremultiplied) as usize - ptr as usize },
        10604usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(colorRampPremultiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpreadMode) as usize - ptr as usize },
        10608usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(SpreadMode)
        )
    );
}
#[doc = "@abstract radial gradient definition.\n\n@discussion\nradial gradient is applied to filling a path."]
pub type vg_lite_radial_gradient_t = vg_lite_radial_gradient;
#[doc = "@abstract color key definition.\n\n@discussion\nThe colorkey have two sections,each section contain R,G,B chanels.Debited as hign_rgb and low_rgb respectively.\nCan be used for blit operation or draw_pattern operation.when enable is ture,the alpha value is used to replace\nthe alpha channel of destination pixel when its RGB channels in range [low_rgb,hign_rgb].After use color key this\nframe,and if the color key is not need in the next frame,disable the color key before next frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_color_key {
    pub enable: u8,
    pub low_r: u8,
    pub low_g: u8,
    pub low_b: u8,
    pub alpha: u8,
    pub hign_r: u8,
    pub hign_g: u8,
    pub hign_b: u8,
}
#[test]
fn bindgen_test_layout_vg_lite_color_key() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_color_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_color_key>(),
        8usize,
        concat!("Size of: ", stringify!(vg_lite_color_key))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_color_key>(),
        1usize,
        concat!("Alignment of ", stringify!(vg_lite_color_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_r) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_g) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_b) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_r) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_g) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_b) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_b)
        )
    );
}
#[doc = "@abstract color key definition.\n\n@discussion\nThe colorkey have two sections,each section contain R,G,B chanels.Debited as hign_rgb and low_rgb respectively.\nCan be used for blit operation or draw_pattern operation.when enable is ture,the alpha value is used to replace\nthe alpha channel of destination pixel when its RGB channels in range [low_rgb,hign_rgb].After use color key this\nframe,and if the color key is not need in the next frame,disable the color key before next frame."]
pub type vg_lite_color_key_t = vg_lite_color_key;
#[doc = "@abstract colorkey definition.\n\n@discussion\nThere are 4 groups of color key states.\nrgb_hi_0, rgb_lo_0, alpha_0, enable_0;\nrgb_hi_1, rgb_lo_1, alpha_1, enable_1;\nrgb_hi_2, rgb_lo_2, alpha_2, enable_2;\nrgb_hi_3, rgb_lo_3, alpha_3, enable_3;\nPriority order:color_key_0 > color_key_1 > color_key_2 > color_key_3."]
pub type vg_lite_color_key4_t = [vg_lite_color_key_t; 4usize];
extern "C" {
    #[doc = "@abstract Allocate a buffer from hardware accessible memory.\n\n@discussion\nIn order for the hardware to access some memory, like a source image or a target buffer, it needs to be allocated first. The\nsupplied <code>vg_lite_buffer_t</code> structure needs to be initialized with the size (width and height) and format of the\nrequested buffer. If the stride is set to zero, this function will fill it in.\n\nThis function will call the kernel to actually allocate the memory and the memory handle and logical and hardware addresses\nwill be filled in by the kernel.\n\n@param buffer\nPointer to the buffer that holds the size and format of the buffer being allocated.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_allocate(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Free a buffer that was previously allocated by {@link vg_lite_allocate}.\n\n@discussion\nFree any memory resources allocated by a previous call to {@link vg_lite_allocate}.\n\n@param buffer\nPointer to a buffer structure that was filled in by {@link vg_lite_allocate}.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_free(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Upload the pixel data to the buffer object.\n\n@discussion\nThe function uploads the pixel data to the buffer object. According to the\nbuffer format, there are 3 planes' data at most (for YUV planars). Note that\nthe format of the data (pixel) to upload must be the same as described in\nthe buffer object. The input data memory pointers should be big enough to\nhold all the data needed by the buffer.\n\n@param buffer\nThe image buffer object.\n\n@param data\nPixel data. For YUV format, it may be up to 3 pointers.\n\n@param stride\nStride for pixel data.\n\n@result\nAny error status during uploading."]
    pub fn vg_lite_buffer_upload(
        buffer: *mut vg_lite_buffer_t,
        data: *mut *mut u8,
        stride: *mut u32,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Map a buffer into hardware accessible address space.\n\n@discussion\nIf you want the use a frame buffer directly as an target buffer, you need to wrap a <code>vg_lite_buffer_t</code> structure\naround it and call the kernel to map the supplied logical or physical address into hardware accessible memory.\n\nFor example, if you know the logical address of the frame buffer, set the memory field of the vg_lite_buffer_t structure\nwith that address and call this function. If you know the physical address, set the memory field to <code>NULL</code> and\nprogram the address field with the physical address.\n\n@param buffer\nPointer to the buffer that holds the size and format of the buffer being allocated. Either the memory or address field\nneeds to be set to a non-zero value to map either a logical or physical address into hardware accessible memory.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_map(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Unmap a buffer that was previously mapped by {@link vg_lite_map}.\n\n@discussion\nFree any memory resources allocated by a previous call to {@link vg_lite_map}.\n\n@param buffer\nPointer to a buffer structure that was filled in by {@link vg_lite_map}.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_unmap(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Fill a (partial) buffer with a specified color.\n\n@discussion\nEither an entire buffer or a partial rectangle of a buffer will be filled with a specific color.\n\nThis function will wait until the hardware is complete, i.e. it is synchronous.\n\n@param target\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the buffer to be filled.\n\n@param rectangle\nPointer to a rectangle that specifies the area to be filled. If <code>rectangle</code> is <code>NULL</code>, the entire target\nbuffer will be filled with the specified color.\n\n@param color\nThe color value to use for filling the buffer. If the buffer is in L8 format, the RGBA color will be converted into a\nluminance value.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_clear(
        target: *mut vg_lite_buffer_t,
        rectangle: *mut vg_lite_rectangle_t,
        color: vg_lite_color_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Copy a source image to the the destination window with a specified matrix that can include translation, rotation,\nscaling, and perspective correction.\n\n@discussion\nA source image is copied to the target using the specified matrix. If the specified matrix is <code>NULL</code>, an identity\nmatrix is assumed, meaning the source will be copied directly on the target at 0,0 location.\n\nAn optional blend mode can be specified that defines the blending of the source onto the target.\n\nAlso, an optional mix color can be specified. The mix color will be multiplied by the source color. If you don't need a mix\ncolor, set the <code>color</code> parameter to 0.\n\nNote that on hardware that doesn't support border scissoring (GC355) the blend mode will be forced to\n<code>VG_LITE_BLEND_SRC_OVER</code> if rotation or perspective is involved.\n\n@param target\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the target of the blit.\n\n@param source\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the source of the blit.\n\n@param matrix\nPointer to a 3x3 matrix that defines the transformation matrix of source pixels into the target. If matrix is\n<code>NULL</code>, an identity matrix is assumed.\n\n@param blend\nThe blending mode to be applied to each image pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param color\nIf non-zero, this color value will be used as a mix color. The mix color gets multiplied with each source pixel before\nblending happens.\n\n@param filter\nThe filter mode to be applied. If no filter mode is required, set this value to\n<code>VG_LITE_FILTER_BI_LINEAR</code> (0x20000).\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_blit(
        target: *mut vg_lite_buffer_t,
        source: *mut vg_lite_buffer_t,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Copy two source images to the the destination window with a specified matrix that can include translation, rotation,\nscaling, and perspective correction.\n\n@discussion\nSource0 and source1 are mixed according to the blend mode,then the image is blended to the target.\n@param target\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the target of the blit.\n\n@param source0\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the source of the blit.\n\n@param source1\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the source of the blit.\n\n@param matrix0\nPointer to a 3x3 matrix that defines the transformation matrix of source0 pixels into the target. If matrix is\n<code>NULL</code>, an identity matrix is assumed.\n\n@param matrix1\nPointer to a 3x3 matrix that defines the transformation matrix of source1 pixels into the target. If matrix is\n<code>NULL</code>, an identity matrix is assumed.\n\n@param blend\nThe blending mode to be applied to each image pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param filter\nThe filter mode to be applied. If no filter mode is required, set this value to\n<code>VG_LITE_FILTER_BI_LINEAR</code> (0x20000).\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_blit2(
        target: *mut vg_lite_buffer_t,
        source0: *mut vg_lite_buffer_t,
        source1: *mut vg_lite_buffer_t,
        matrix0: *mut vg_lite_matrix_t,
        matrix1: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_blit_rect(
        target: *mut vg_lite_buffer_t,
        source: *mut vg_lite_buffer_t,
        rect: *mut u32,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Initialize a vglite context.\n\n@discussion\nThe {@link vg_lite_draw} function requires a draw context to be initialized. There is only one draw context per process, so\nthis function has be called once in your application if any draw command will be used. If this would be the first context that\naccesses the hardware, the hardware will be turned on and initialized.\n\nThe difference between a blit and draw context is that the draw context has a larger command buffer and allocates a\ntessellation buffer for the hardware. The size of the tessellation buffer can be specified, and that size will be aligned to\nthe minimum required alignment of the hardware by the kernel. If you make the tessellation buffer smaller, less memory will\nbe allocated, but a path might be sent down to the hardware multiple times because the hardware will walk the target with the\nprovided tessellation window size, so performance might go down. It is good practice to set the tessellation buffer size to the\nmost common path size. For example, if all you do is render up to 24-pt fonts, you can set the tessellation buffer to be\n24x24.\n\n@param tessellation_width\nThe width of the tessellation window.\n\n@param tessellation_height\nThe height of the tessellation window.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_init(tessellation_width: i32, tessellation_height: i32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Destroy a vglite context.\n\n@discussion\nDestroy a draw context that was previously initialized by {@link vg_lite_draw_init}.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_close() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api explicitly submits the command buffer to GPU and waits for it to complete.\n\n@param none.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_finish() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api explicitly submits the command buffer to GPU without waiting for it to complete.\n\n@param none.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_flush() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Draw a path to a target buffer.\n\n@discussion\nThe specified path will be transformed by the given matrix and drawn into the specified target buffer using the supplied color.\nBlending can be specified.\n\n@param target\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the target of the draw.\n\n@param path\nPointer to a <code>vg_lite_path_t</code> structure that describes the path to draw.\n\n@param fill_rule\nSpecified fill rule for the path.\n\n@param matrix\nPointer to a 3x3 matrix that defines the transformation matrix of the path. If <code>matrix</code> is <code>NULL</code>, an\nidentity matrix is assumed which is usually a bad idea since the path can be anything.\n\n@param blend\nThe blending mode to be applied to each drawn pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param color\nThe color applied to each pixel drawn by the path.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_draw(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Get the value of register from register's address.\n\n@discussion\nThis address will be the AHB Byte address of the register whose value you want to dump.\nRefer to the Vivante AHB Register Specification document for register descriptions.\nThe valid range for VGLite cores is usually 0x0 to 0x1FF and 0xA00 to 0xA7F.\n\n@param address\nAddress of register which is needed to get its value.\n\n@param result\nThe register's value.\n"]
    pub fn vg_lite_get_register(address: u32, result: *mut u32) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_info(info: *mut vg_lite_info_t);
}
extern "C" {
    pub fn vg_lite_get_product_info(
        name: *mut ::std::os::raw::c_char,
        chip_id: *mut u32,
        chip_rev: *mut u32,
    ) -> u32;
}
extern "C" {
    #[doc = "@abstract Queried whether the specified feature is available.\n\n@param feature\nFeature to be verified.\n\n@return\nThe feature is supported (1) or not (0)."]
    pub fn vg_lite_query_feature(feature: vg_lite_feature_t) -> u32;
}
extern "C" {
    #[doc = "@abstract This api initializes a path object by given member values.\n\n@param path\nThe path object.\n\n@param data_format\nThe coordinate data format of the path. One of S8, S16, S32 and FP32.\n\n@param quality\nThe rendering quality (AA level) of the path.\n\n@param path_length\nThe memory length of the path data.\n\n@param path_data\nThe path data.\n\n@param min_x\nThe min x of the bounding box.\n\n@param min_y\nThe min y of the bounding box.\n\n@param max_x\nThe max x of the bounding box.\n\n@param max_y\nThe max y of the bounding box.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_init_path(
        path: *mut vg_lite_path_t,
        data_format: vg_lite_format_t,
        quality: vg_lite_quality_t,
        path_length: u32,
        path_data: *mut ::std::os::raw::c_void,
        min_x: vg_lite_float_t,
        min_y: vg_lite_float_t,
        max_x: vg_lite_float_t,
        max_y: vg_lite_float_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api initializes a path object which include arc command by given member values.\n\n@param path\nThe path object.\n\n@param data_format\nThe coordinate data format of the path. Should be FP32.\n\n@param quality\nThe rendering quality (AA level) of the path.\n\n@param path_length\nThe memory length of the path data.\n\n@param path_data\nThe given path data which inlcude arc command.\n\n@param min_x\nThe min x of the bounding box.\n\n@param min_y\nThe min y of the bounding box.\n\n@param max_x\nThe max x of the bounding box.\n\n@param max_y\nThe max y of the bounding box.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_init_arc_path(
        path: *mut vg_lite_path_t,
        data_format: vg_lite_format_t,
        quality: vg_lite_quality_t,
        path_length: u32,
        path_data: *mut ::std::os::raw::c_void,
        min_x: vg_lite_float_t,
        min_y: vg_lite_float_t,
        max_x: vg_lite_float_t,
        max_y: vg_lite_float_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api clears the path member values.\n\n@discussion It frees the hw memory if path was ever uploaded.\n\n@param path\nThe path object.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_clear_path(path: *mut vg_lite_path_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Calculate the path command buffer length (in bytes).\n\n@discussion The app should be response for allocating a buffer according to\nthe buffer length calculated by this function. Then the buffer is used by\nthe path as command buffer. The driver does not do allocation for the buffer.\n\n@param cmd\nThe opcode array to construct the path.\n\n@param count\nThe count of opcodes.\n\n@param format\nThe data format of the coordinate (VG_LITE_S8, S16, S32, FP32)\n\n@result\nReturn the actual length of the path command buffer."]
    pub fn vg_lite_path_calc_length(cmd: *mut u8, count: u32, format: vg_lite_format_t) -> i32;
}
extern "C" {
    #[doc = "@abstract Assemble the command buffer for the path.\n\n@discussion The command buffer is allocated by the application and assigned\nto the path. The function make the final GPU command buffer for the path based\non the input opcodes (cmd) and coordinates (data). Note that the Application\nmust be responsible to alloate a big enough buffer for the path.\n\n@param path\nThe path object.\n\n@param cmd\nThe opcode array to construct the path.\n\n@param data\nThe coordinate data array to construct the path.\n\n@param seg_count\nThe count of the opcodes.\n"]
    pub fn vg_lite_path_append(
        path: *mut vg_lite_path_t,
        cmd: *mut u8,
        data: *mut ::std::os::raw::c_void,
        seg_count: u32,
    );
}
extern "C" {
    #[doc = "@abstract Upload a path to GPU memory.\n\n@discussion\nIn normal cases, the VGLite driver will copy any path data into a command buffer structure during runtime. This does take some\ntime if there are many paths to be rendered. Also, in an embedded system the path data wont change - so it makes sense to\nupload the path data into GPU memory in such a form the GPU can directly access it.\n\nThis function will allocate a buffer that will contain the path data and the required command buffer header and footer data for\nthe GPU to access the data directly.\n\n@param path\nPointer to a <code>vg_lite_path_t</code> structure that contains the path to be uploaded. Some fields in this structure will be\nmodified to point to a command buffer instead of the native path data.\n\n@result\nA pointer to a <code>vg_lite_buffer_t</code> structure that contains the command buffer and path data after uploading it to GPU\nmemory. <code>NULL</code> is returned if there is an error."]
    pub fn vg_lite_upload_path(path: *mut vg_lite_path_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Set the current CLUT (Color Look Up Table) for index image to use.\n\n@discussion\nThis is a global context state. Once it's set (Not NULL), when an indexed format image is rendered, the image color will\nbe got from the CLUT by the image's pixels as indecies.\n\n@param count\nThis is the count of the colors in the look up table.\nFor index 1, up to 2 colors in the table;\nFor index 2, up to 4 colors in the table;\nFor index 4, up to 16 colors in the table;\nFor index 8, up to 256 colros in the table.\nDriver is not responsible to check the validation of the CLUT.\n\n@param colors\nThis pointer is directly programmed to the command buffer. So it won't take effect\nunless the command buffer is submitted. The color is in ARGB format with A staying at the high bits.\n\n@result\nError code. Currently always returns VG_LITE_SUCCESS since it does not do any checks."]
    pub fn vg_lite_set_CLUT(count: u32, colors: *mut u32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Fill a path with an image pattern.\n\n@discussion\nThe specified path will be transformed by the given matrix and filled by the tranformed image pattern.\n\n@param path\nPointer to a <code>vg_lite_path_t</code> structure that describes the path to draw.\n\n@param fill_rule\nSpecified fill rule for the path.\n\n@param matrix0\nPointer to a 3x3 matrix that defines the transformation matrix of the path. If <code>matrix</code> is <code>NULL</code>, an\nidentity matrix is assumed which is usually a bad idea since the path can be anything.\n\n@param source\nPointer to a <code>vg_lite_buffer_t</code> structure that describes the source of the image pattern.\n\n@param matrix1\nPointer to a 3x3 matrix that defines the transformation matrix of source pixels into the target. If matrix is\n<code>NULL</code>, an identity matrix is assumed.\n\n@param blend\nThe blending mode to be applied to each drawn pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param pattern_mode\nThe tiling mode that applied to the pixels out of the image after transformed.\n\n@param pattern_color\nThe pattern_color applied by pattern_mode VG_LITE_PATTERN_COLOR. When pixels are out of the image after transformed,\nthey are applied \"pattern_color\".\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_draw_pattern(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        matrix0: *mut vg_lite_matrix_t,
        source: *mut vg_lite_buffer_t,
        matrix1: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        pattern_mode: vg_lite_pattern_mode_t,
        pattern_color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Init the linear gradient object.\n\n@discussion\nThis API initialize the grad object to its default settings. Since grad has\nan internal buffer object, this API will init the buffer object for rendering use.\n\n@param grad\nThis is the vg_lite_linear_gradient_t object to be initialized.\n\n@result\nError code, in case the buffer can't be created."]
    pub fn vg_lite_init_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Set the linear gradient members.\n\n@discussion\nThis API sets the values for the members of the gradient definition.\n\n@param grad\nThis is the vg_lite_linear_gradient_t object to be set.\n\n@param count\nThis is the count of the colors in grad.\nThe maxmum color stop count is defined by VLC_MAX_GRAD, which is currently 16.\n\n@param colors\nThis is the color array for the gradient stops. The color is in ARGB8888 format\nwith alpha at the higher byte.\n\n@result\nError code. VG_LITE_INVALID_ARGUMENTS to indicate the parameters are wrong."]
    pub fn vg_lite_set_grad(
        grad: *mut vg_lite_linear_gradient_t,
        count: u32,
        colors: *mut u32,
        stops: *mut u32,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Set the radial gradient members.\n\n@discussion\nThis API sets the values for the members of the radial gradient definition.\n\n@param grad\nThis is the vg_lite_radial_gradient_t object to be set.\n\n@param count\nThis is the count of the colors in grad.\nThe maxmum color stop count is defined by MAX_COLOR_RAMP_STOPS, which is currently 256.\n\n@param vgColorRamp\nThis is the stop for the radial gradient.The number of parameters is 5,and give the offset and\ncolor of the stop.Each stop is defined by a floating-point offset value and four floating-point values\ncontaining the sRGBA color and alpha value associated with each stop, in the form of a non-premultiplied\n(R, G, B, alpha) quad.And the range of all parameters in it is [0,1].\n\n@param radialGradient\nThe radial gradient parameters are supplied as a vector of 5 floats in the order {cx,cy,fx,fy,r}.\nthe range of all parameters in it is [0,1].The meaning of the parameters in it is:(cx,cy) is center point,\n(fx,fy) is focal point, and r is radius.\n\n@param SpreadMode\nThe tiling mode that applied to the pixels out of the paint after transformed.\n\n@param colorRampPremultiplied\nThe parameter controls whether color and alpha values are interpolated in premultiplied or non-premultiplied\nform.\n\n@result\nError code. VG_LITE_INVALID_ARGUMENTS to indicate the parameters are wrong."]
    pub fn vg_lite_set_rad_grad(
        grad: *mut vg_lite_radial_gradient_t,
        count: u32,
        vgColorRamp: *mut vg_lite_color_ramp_t,
        radialGradient: vg_lite_radial_gradient_parameter_t,
        SpreadMode: vg_lite_radial_gradient_spreadmode_t,
        colorRampPremultiplied: u8,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Update or generate the corresponding image object to render with.\n\n@discussion\nThe vg_lite_linear_gradient_t object has an image buffer which is used to render\nthe gradient pattern. The image buffer will be create/updated by the corresponding\ngrad parameters.\n\n@param grad\nThis is the vg_lite_linear_gradient_t object to be upated from.\n\n@result\nError code."]
    pub fn vg_lite_update_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Update or generate the corresponding image object to render with.\n\n@discussion\nThe vg_lite_radial_gradient_t object has an image buffer which is used to render\nthe radial gradient paint. The image buffer will be create/updated by the corresponding\ngrad parameters.\n\n@param grad\nThis is the vg_lite_radial_gradient_t object to be upated from.\n\n@result\nError code."]
    pub fn vg_lite_update_rad_grad(grad: *mut vg_lite_radial_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Clear the gradient object.\n\n@discussion\nThis will reset the grad members and free the image buffer's memory.\n\n@param grad\nThis is the vg_lite_linear_gradient_t object to be cleared.\n\n@result\nError code."]
    pub fn vg_lite_clear_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Clear the radial gradient object.\n\n@discussion\nThis will reset the grad members and free the image buffer's memory.\n\n@param grad\nThis is the vg_lite_radial_gradient_t object to be cleared.\n\n@result\nError code."]
    pub fn vg_lite_clear_rad_grad(grad: *mut vg_lite_radial_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Get the pointer to the grad object's matrix.\n\n@discussion\nThis function get the pointer to the gradient object's matrix. Thus the app\ncan manipulate the matrix to render the gradient path correctly.\n\n@param grad\nThis is the vg_lite_linear_gradient_t object where to get the matrix.\n\n@result\nThe pointer to the matrix."]
    pub fn vg_lite_get_grad_matrix(grad: *mut vg_lite_linear_gradient_t) -> *mut vg_lite_matrix_t;
}
extern "C" {
    #[doc = "@abstract Get the pointer to the grad object's matrix.\n\n@discussion\nThis function get the pointer to the radial gradient object's matrix. Thus the app\ncan manipulate the matrix to render the radial gradient path correctly.\n\n@param grad\nThis is the vg_lite_radial_gradient_t object where to get the matrix.\n\n@result\nThe pointer to the matrix."]
    pub fn vg_lite_get_rad_grad_matrix(
        grad: *mut vg_lite_radial_gradient_t,
    ) -> *mut vg_lite_matrix_t;
}
extern "C" {
    #[doc = "@abstract Fill a path with an image pattern.\n\n@discussion\nThe specified path will be transformed by the given matrix and filled by the tranformed image pattern.\n\n@param path\nPointer to a <code>vg_lite_path_t</code> structure that describes the path to draw.\n\n@param fill_rule\nSpecified fill rule for the path.\n\n@param matrix0\nPointer to a 3x3 matrix that defines the transformation matrix of the path. If <code>matrix</code> is <code>NULL</code>, an\nidentity matrix is assumed which is usually a bad idea since the path can be anything.\n\n@param grad\nPointer to the gradient object that will be filled the path with.\n\n@param blend\nThe blending mode to be applied to each drawn pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param pattern_mode\nThe tiling mode that applied to the pixels out of the image after transformed.\n\n@param pattern_color\nThe pattern_color applied by pattern_mode VG_LITE_PATTERN_COLOR. When pixels are out of the image after transformed,\nthey are applied \"pattern_color\".\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_draw_gradient(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        matrix: *mut vg_lite_matrix_t,
        grad: *mut vg_lite_linear_gradient_t,
        blend: vg_lite_blend_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Fill a path with a radial gradient.\n\n@discussion\nThe specified path will be transformed by the given matrix and filled by the tranformed radial gradient.\n\n@param path\nPointer to a <code>vg_lite_path_t</code> structure that describes the path to draw.\n\n@param fill_rule\nSpecified fill rule for the path.\n\n@param path_matrix\nPointer to a 3x3 matrix that defines the transformation matrix of the path. If <code>matrix</code> is <code>NULL</code>, an\nidentity matrix is assumed which is usually a bad idea since the path can be anything.\n\n@param grad\nThis is the vg_lite_radial_gradient_t object to be set.\n\n@param paint_color\nSpecifies the paint color vg_lite_color_t RGBA value to applied by VG_LITE_RADIAL_GRADIENT_SPREAD_FILL,which set by fuction\nvg_lite_set_rad_grad. When pixels are out of the image after transformed,this paint_color is applied to them,See enum\nvg_lite_radial_gradient_spreadmode_t.\n\n@param blend\nThe blending mode to be applied to each drawn pixel. If no blending is required, set this value to\n<code>VG_LITE_BLEND_NONE</code> (0).\n\n@param filter\nSpecified the filter mode vg_lite_filter_t enum value to be applied to each drawn pixel.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_draw_radial_gradient(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        path_matrix: *mut vg_lite_matrix_t,
        grad: *mut vg_lite_radial_gradient_t,
        paint_color: vg_lite_color_t,
        blend: vg_lite_blend_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Load an identity matrix.\n\n@discussion\nLoad an identity matrix into a matrix variable.\n\n@param matrix\nPointer to a <code>vg_lite_matrix_t</code> structure that will be loaded with an identity matrix."]
    pub fn vg_lite_identity(matrix: *mut vg_lite_matrix_t);
}
extern "C" {
    #[doc = "@abstract Translate a matrix.\n\n@discussion\nTranslate a matrix to a new position.\n\n@param x\nX location of the transformation.\n\n@param y\nY location of the transformation.\n\n@param matrix\nPointer to a <code>vg_lite_matrix_t</code> structure that will be translated."]
    pub fn vg_lite_translate(x: vg_lite_float_t, y: vg_lite_float_t, matrix: *mut vg_lite_matrix_t);
}
extern "C" {
    #[doc = "@abstract Scale a matrix.\n\n@discussion\nScale a matrix in both x and y directions.\n\n@param scale_x\nHorizontal scale.\n\n@param scale_y\nVertical scale.\n\n@param matrix\nPointer to a <code>vg_lite_matrix_t</code> structure that will be scaled."]
    pub fn vg_lite_scale(
        scale_x: vg_lite_float_t,
        scale_y: vg_lite_float_t,
        matrix: *mut vg_lite_matrix_t,
    );
}
extern "C" {
    #[doc = "@abstract Rotate a matrix.\n\n@discussion\nRotate a matrix a certain number of degrees.\n\n@param degrees\nNumber of degrees to rotate the matrix around. Positive numbers rotate counter clock wise.\n\n@param matrix\nPointer to a <code>vg_lite_matrix_t</code> structure that will be rotated."]
    pub fn vg_lite_rotate(degrees: vg_lite_float_t, matrix: *mut vg_lite_matrix_t);
}
extern "C" {
    #[doc = "@abstract projective transformation.\n\n@discussion\nset perspective matrix.\n\n@param degrees\npx: indicate w0 of perspective transformation matrix\npy: indicate w1 of perspective transformation matrix\n@param matrix\nPointer to a <code>vg_lite_matrix_t</code> structure that will be rotated."]
    pub fn vg_lite_perspective(
        px: vg_lite_float_t,
        py: vg_lite_float_t,
        matrix: *mut vg_lite_matrix_t,
    );
}
extern "C" {
    #[doc = "@abstract Set the command buffer size.\n\n@discussion\nIn the rt device, the memory was limited, need to set the command buffer\nsize by the chip.\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_command_buffer_size(size: u32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Set scissor used for render target's boundary.\n\n@discussion\nThis function is used to set a scissor into render target so that the out region\nof scissor boundary is not drawn.\n\n@param x, y, right, bottom\nThe scissor bounds which specifies the left, top, right, and bottom of the region.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_scissor(x: i32, y: i32, right: i32, bottom: i32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Enable scissor.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_enable_scissor() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Disable scissor.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_disable_scissor() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract query the remaining allocate contiguous video memory.\n\n@param size\nThis is a pointer to remaining allocate contiguous video memory.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>.The result correctly returns VG_LITE_SUCCESS,\nreturn VG_LITE_NO_CONTEXT if not initialized."]
    pub fn vg_lite_mem_avail(size: *mut u32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract set the image/source global alpha.\n\n@param alpha_mode\nDefined by <code>vg_lite_global_alpha_t</code>.\n\n@param alpha_value\nThe image global alpha value to set.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>.\nPossible return value in this function:\nVG_LITE_SUCCESS,the result correctly\nVG_LITE_NOT_SUPPORT, if not support global alpha."]
    pub fn vg_lite_set_image_global_alpha(
        alpha_mode: vg_lite_global_alpha_t,
        alpha_value: u8,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract set the destination global alpha.\n\n@param alpha_mode\nDefined by <code>vg_lite_global_alpha_t</code>.\n\n@param alpha_value\nThe destination global alpha value to set.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>.\nPossible return value in this function:\nVG_LITE_SUCCESS,the result correctly\nVG_LITE_NOT_SUPPORT, if not support global alpha."]
    pub fn vg_lite_set_dest_global_alpha(
        alpha_mode: vg_lite_global_alpha_t,
        alpha_value: u8,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract use to set the colorkey.\n\n@param colorkey\nDefined by <code>vg_lite_color_key4_t</code>.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>.\nPossible return value in this function:\nVG_LITE_SUCCESS,the result correctly\nVG_LITE_NOT_SUPPORT, if not support colorkey."]
    pub fn vg_lite_set_color_key(colorkey: *mut vg_lite_color_key_t) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api use to set flexa stream id.\n\n@param stream_id\nThe flexa stream id.Differnt modules use different stream id.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_flexa_stream_id(stream_id: u8) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api set flexa current background buffer.\n\n@param buffer\nThe background buffer address,it's the target buffer of VG.\n\n@param background_segment_count\nThe count of background buffer segment.The range of count is 0 to background segment number.\nThe background segment number is equal to the height of the background buffer divided by 16.\n\n@param background_segment_size\nThe size of one background sigment buffer.The value is equal to 16 * stride.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_flexa_current_background_buffer(
        stream_id: u8,
        buffer: *mut vg_lite_buffer_t,
        background_segment_count: u32,
        background_segment_size: u32,
    ) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract Enable flexa.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_enable_flexa() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract disable flexa.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_disable_flexa() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract set stop flag.When executing the last frame of flexa mode,call this API.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_flexa_stop_frame() -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api use to control dither function switch.Dither is turned off by default.\n\n@param enable\n0 means turn off the dither function. 1 means turn on the dither function.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_dither(enable: ::std::os::raw::c_int) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api use to set a specified memory used as tessellation buffer.\n\n@param physical\nThe physical address of this memory.This address should align to 64.\n\n@param size\nThe tessellation buffer's size,tessellation buffer size = target buffer's height * 128B.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_ts_buffer(physical: u32, size: u32) -> vg_lite_error_t;
}
extern "C" {
    #[doc = "@abstract This api use to set a specified memory used as command buffer.\n\n@param physical\nThe physical address of this memory.This address should align to 64.And this memory will split\nto two command buffer to use.\n\n@param size\nThe size of this memory,This size should align to 128.\n\n@result\nReturns the status as defined by <code>vg_lite_error_t</code>."]
    pub fn vg_lite_set_command_buffer(physical: u32, size: u32) -> vg_lite_error_t;
}
