/* automatically generated by rust-bindgen 0.63.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VGLITE_HEADER_VERSION: u32 = 7;
pub const VGLITE_VERSION_3_0: u32 = 1;
pub const VGL_FALSE: u32 = 0;
pub const VGL_TRUE: u32 = 1;
pub const VLC_OP_END: u32 = 0;
pub const VLC_OP_CLOSE: u32 = 1;
pub const VLC_OP_MOVE: u32 = 2;
pub const VLC_OP_MOVE_REL: u32 = 3;
pub const VLC_OP_LINE: u32 = 4;
pub const VLC_OP_LINE_REL: u32 = 5;
pub const VLC_OP_QUAD: u32 = 6;
pub const VLC_OP_QUAD_REL: u32 = 7;
pub const VLC_OP_CUBIC: u32 = 8;
pub const VLC_OP_CUBIC_REL: u32 = 9;
pub const VLC_OP_BREAK: u32 = 10;
pub const VLC_OP_HLINE: u32 = 11;
pub const VLC_OP_HLINE_REL: u32 = 12;
pub const VLC_OP_VLINE: u32 = 13;
pub const VLC_OP_VLINE_REL: u32 = 14;
pub const VLC_OP_SQUAD: u32 = 15;
pub const VLC_OP_SQUAD_REL: u32 = 16;
pub const VLC_OP_SCUBIC: u32 = 17;
pub const VLC_OP_SCUBIC_REL: u32 = 18;
pub const VLC_OP_SCCWARC: u32 = 19;
pub const VLC_OP_SCCWARC_REL: u32 = 20;
pub const VLC_OP_SCWARC: u32 = 21;
pub const VLC_OP_SCWARC_REL: u32 = 22;
pub const VLC_OP_LCCWARC: u32 = 23;
pub const VLC_OP_LCCWARC_REL: u32 = 24;
pub const VLC_OP_LCWARC: u32 = 25;
pub const VLC_OP_LCWARC_REL: u32 = 26;
pub const VLC_MAX_COLOR_RAMP_STOPS: u32 = 256;
pub const VLC_MAX_GRADIENT_STOPS: u32 = 16;
pub const VLC_GRADIENT_BUFFER_WIDTH: u32 = 1024;
pub const VG_LITE_ERROR: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type vg_lite_bool_t = ::std::os::raw::c_int;
pub type vg_lite_uint8_t = ::std::os::raw::c_uchar;
pub type vg_lite_int8_t = ::std::os::raw::c_char;
pub type vg_lite_int16_t = ::std::os::raw::c_short;
pub type vg_lite_uint16_t = ::std::os::raw::c_ushort;
pub type vg_lite_int32_t = ::std::os::raw::c_int;
pub type vg_lite_uint32_t = ::std::os::raw::c_uint;
pub type vg_lite_uint64_t = ::std::os::raw::c_ulonglong;
pub type vg_lite_float_t = f32;
pub type vg_lite_double_t = f64;
pub type vg_lite_char = ::std::os::raw::c_char;
pub type vg_lite_string = *mut ::std::os::raw::c_char;
pub type vg_lite_pointer = *mut ::std::os::raw::c_void;
pub type vg_lite_void = ::std::os::raw::c_void;
pub type vg_lite_color_t = ::std::os::raw::c_uint;
pub const vg_lite_error_VG_LITE_SUCCESS: vg_lite_error = 0;
#[doc = " Success."]
pub const vg_lite_error_VG_LITE_INVALID_ARGUMENT: vg_lite_error = 1;
#[doc = " An invalid argument was specified."]
pub const vg_lite_error_VG_LITE_OUT_OF_MEMORY: vg_lite_error = 2;
#[doc = " Out of memory."]
pub const vg_lite_error_VG_LITE_NO_CONTEXT: vg_lite_error = 3;
#[doc = " No context or an unintialized context specified."]
pub const vg_lite_error_VG_LITE_TIMEOUT: vg_lite_error = 4;
#[doc = " A timeout has occurred during a wait."]
pub const vg_lite_error_VG_LITE_OUT_OF_RESOURCES: vg_lite_error = 5;
#[doc = " Out of system resources."]
pub const vg_lite_error_VG_LITE_GENERIC_IO: vg_lite_error = 6;
#[doc = " Cannot communicate with the kernel driver."]
pub const vg_lite_error_VG_LITE_NOT_SUPPORT: vg_lite_error = 7;
#[doc = " Function call not supported."]
pub const vg_lite_error_VG_LITE_ALREADY_EXISTS: vg_lite_error = 8;
#[doc = " Object already exists"]
pub const vg_lite_error_VG_LITE_NOT_ALIGNED: vg_lite_error = 9;
#[doc = " Data alignment error"]
pub const vg_lite_error_VG_LITE_FLEXA_TIME_OUT: vg_lite_error = 10;
#[doc = " VG timeout requesting for segment buffer"]
pub const vg_lite_error_VG_LITE_FLEXA_HANDSHAKE_FAIL: vg_lite_error = 11;
pub type vg_lite_error = ::std::os::raw::c_uint;
pub use self::vg_lite_error as vg_lite_error_t;
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_INDEX_FORMAT: vg_lite_feature = 0;
pub const vg_lite_feature_gcFEATURE_BIT_VG_SCISSOR: vg_lite_feature = 1;
pub const vg_lite_feature_gcFEATURE_BIT_VG_BORDER_CULLING: vg_lite_feature = 2;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RGBA2_FORMAT: vg_lite_feature = 3;
pub const vg_lite_feature_gcFEATURE_BIT_VG_QUALITY_8X: vg_lite_feature = 4;
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_FASTCLAER: vg_lite_feature = 5;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RADIAL_GRADIENT: vg_lite_feature = 6;
pub const vg_lite_feature_gcFEATURE_BIT_VG_GLOBAL_ALPHA: vg_lite_feature = 7;
pub const vg_lite_feature_gcFEATURE_BIT_VG_RGBA8_ETC2_EAC: vg_lite_feature = 8;
pub const vg_lite_feature_gcFEATURE_BIT_VG_COLOR_KEY: vg_lite_feature = 9;
pub const vg_lite_feature_gcFEATURE_BIT_VG_DOUBLE_IMAGE: vg_lite_feature = 10;
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUV_OUTPUT: vg_lite_feature = 11;
pub const vg_lite_feature_gcFEATURE_BIT_VG_FLEXA: vg_lite_feature = 12;
pub const vg_lite_feature_gcFEATURE_BIT_VG_24BIT: vg_lite_feature = 13;
pub const vg_lite_feature_gcFEATURE_BIT_VG_DITHER: vg_lite_feature = 14;
pub const vg_lite_feature_gcFEATURE_BIT_VG_USE_DST: vg_lite_feature = 15;
pub const vg_lite_feature_gcFEATURE_BIT_VG_PE_CLEAR: vg_lite_feature = 16;
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_INPUT: vg_lite_feature = 17;
pub const vg_lite_feature_gcFEATURE_BIT_VG_DEC_COMPRESS: vg_lite_feature = 18;
pub const vg_lite_feature_gcFEATURE_BIT_VG_LINEAR_GRADIENT_EXT: vg_lite_feature = 19;
pub const vg_lite_feature_gcFEATURE_BIT_VG_MASK: vg_lite_feature = 20;
pub const vg_lite_feature_gcFEATURE_BIT_VG_MIRROR: vg_lite_feature = 21;
pub const vg_lite_feature_gcFEATURE_BIT_VG_GAMMA: vg_lite_feature = 22;
pub const vg_lite_feature_gcFEATURE_BIT_VG_NEW_BLEND_MODE: vg_lite_feature = 23;
pub const vg_lite_feature_gcFEATURE_BIT_VG_STENCIL: vg_lite_feature = 24;
pub const vg_lite_feature_gcFEATURE_BIT_VG_SRC_PREMULTIPLIED: vg_lite_feature = 25;
#[doc = " Valid only if gcFEATURE_BIT_VG_HW_PREMULTIPLY is 0"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_HW_PREMULTIPLY: vg_lite_feature = 26;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_COLOR_TRANSFORMATION: vg_lite_feature = 27;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_LVGL_SUPPORT: vg_lite_feature = 28;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_INDEX_ENDIAN: vg_lite_feature = 29;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_24BIT_PLANAR: vg_lite_feature = 30;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_PIXEL_MATRIX: vg_lite_feature = 31;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_NEW_IMAGE_INDEX: vg_lite_feature = 32;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_PARALLEL_PATHS: vg_lite_feature = 33;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_STRIPE_MODE: vg_lite_feature = 34;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_DEC_INPUT: vg_lite_feature = 35;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_GAUSSIAN_BLUR: vg_lite_feature = 36;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_RECTANGLE_TILED_OUT: vg_lite_feature = 37;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_TESSELLATION_TILED_OUT: vg_lite_feature = 38;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_IM_REPEAT_REFLECT: vg_lite_feature = 39;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUY2_INPUT: vg_lite_feature = 40;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUV_INPUT: vg_lite_feature = 41;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_YUV_TILED_INPUT: vg_lite_feature = 42;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_AYUV_INPUT: vg_lite_feature = 43;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_BIT_VG_16PIXELS_ALIGN: vg_lite_feature = 44;
#[doc = " HW multiplier can accept either premultiplied or not"]
pub const vg_lite_feature_gcFEATURE_COUNT: vg_lite_feature = 45;
pub type vg_lite_feature = ::std::os::raw::c_uint;
pub use self::vg_lite_feature as vg_lite_feature_t;
pub const vg_lite_quality_VG_LITE_HIGH: vg_lite_quality = 0;
#[doc = " High quality 16x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_UPPER: vg_lite_quality = 1;
#[doc = " Upper quality 8x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_MEDIUM: vg_lite_quality = 2;
#[doc = " Medium quality 4x anti-aliasing path."]
pub const vg_lite_quality_VG_LITE_LOW: vg_lite_quality = 3;
pub type vg_lite_quality = ::std::os::raw::c_uint;
pub use self::vg_lite_quality as vg_lite_quality_t;
pub const vg_lite_format_VG_LITE_S8: vg_lite_format = 0;
#[doc = " Signed 8-bit coordinates."]
pub const vg_lite_format_VG_LITE_S16: vg_lite_format = 1;
#[doc = " Signed 16-bit coordinates."]
pub const vg_lite_format_VG_LITE_S32: vg_lite_format = 2;
#[doc = " Signed 32-bit coordinates."]
pub const vg_lite_format_VG_LITE_FP32: vg_lite_format = 3;
pub type vg_lite_format = ::std::os::raw::c_uint;
pub use self::vg_lite_format as vg_lite_format_t;
pub const vg_lite_buffer_format_VG_sRGBX_8888: vg_lite_buffer_format = 0;
pub const vg_lite_buffer_format_VG_sRGBA_8888: vg_lite_buffer_format = 1;
pub const vg_lite_buffer_format_VG_sRGBA_8888_PRE: vg_lite_buffer_format = 2;
pub const vg_lite_buffer_format_VG_sRGB_565: vg_lite_buffer_format = 3;
pub const vg_lite_buffer_format_VG_sRGBA_5551: vg_lite_buffer_format = 4;
pub const vg_lite_buffer_format_VG_sRGBA_4444: vg_lite_buffer_format = 5;
pub const vg_lite_buffer_format_VG_sL_8: vg_lite_buffer_format = 6;
pub const vg_lite_buffer_format_VG_lRGBX_8888: vg_lite_buffer_format = 7;
pub const vg_lite_buffer_format_VG_lRGBA_8888: vg_lite_buffer_format = 8;
pub const vg_lite_buffer_format_VG_lRGBA_8888_PRE: vg_lite_buffer_format = 9;
pub const vg_lite_buffer_format_VG_lL_8: vg_lite_buffer_format = 10;
pub const vg_lite_buffer_format_VG_A_8: vg_lite_buffer_format = 11;
pub const vg_lite_buffer_format_VG_BW_1: vg_lite_buffer_format = 12;
pub const vg_lite_buffer_format_VG_A_1: vg_lite_buffer_format = 13;
pub const vg_lite_buffer_format_VG_A_4: vg_lite_buffer_format = 14;
pub const vg_lite_buffer_format_VG_sXRGB_8888: vg_lite_buffer_format = 64;
pub const vg_lite_buffer_format_VG_sARGB_8888: vg_lite_buffer_format = 65;
pub const vg_lite_buffer_format_VG_sARGB_8888_PRE: vg_lite_buffer_format = 66;
pub const vg_lite_buffer_format_VG_sARGB_1555: vg_lite_buffer_format = 68;
pub const vg_lite_buffer_format_VG_sARGB_4444: vg_lite_buffer_format = 69;
pub const vg_lite_buffer_format_VG_lXRGB_8888: vg_lite_buffer_format = 71;
pub const vg_lite_buffer_format_VG_lARGB_8888: vg_lite_buffer_format = 72;
pub const vg_lite_buffer_format_VG_lARGB_8888_PRE: vg_lite_buffer_format = 73;
pub const vg_lite_buffer_format_VG_sBGRX_8888: vg_lite_buffer_format = 128;
pub const vg_lite_buffer_format_VG_sBGRA_8888: vg_lite_buffer_format = 129;
pub const vg_lite_buffer_format_VG_sBGRA_8888_PRE: vg_lite_buffer_format = 130;
pub const vg_lite_buffer_format_VG_sBGR_565: vg_lite_buffer_format = 131;
pub const vg_lite_buffer_format_VG_sBGRA_5551: vg_lite_buffer_format = 132;
pub const vg_lite_buffer_format_VG_sBGRA_4444: vg_lite_buffer_format = 133;
pub const vg_lite_buffer_format_VG_lBGRX_8888: vg_lite_buffer_format = 135;
pub const vg_lite_buffer_format_VG_lBGRA_8888: vg_lite_buffer_format = 136;
pub const vg_lite_buffer_format_VG_lBGRA_8888_PRE: vg_lite_buffer_format = 137;
pub const vg_lite_buffer_format_VG_sXBGR_8888: vg_lite_buffer_format = 192;
pub const vg_lite_buffer_format_VG_sABGR_8888: vg_lite_buffer_format = 193;
pub const vg_lite_buffer_format_VG_sABGR_8888_PRE: vg_lite_buffer_format = 194;
pub const vg_lite_buffer_format_VG_sABGR_1555: vg_lite_buffer_format = 196;
pub const vg_lite_buffer_format_VG_sABGR_4444: vg_lite_buffer_format = 197;
pub const vg_lite_buffer_format_VG_lXBGR_8888: vg_lite_buffer_format = 199;
pub const vg_lite_buffer_format_VG_lABGR_8888: vg_lite_buffer_format = 200;
pub const vg_lite_buffer_format_VG_lABGR_8888_PRE: vg_lite_buffer_format = 201;
pub const vg_lite_buffer_format_VG_LITE_RGBA8888: vg_lite_buffer_format = 1024;
pub const vg_lite_buffer_format_VG_LITE_BGRA8888: vg_lite_buffer_format = 1025;
pub const vg_lite_buffer_format_VG_LITE_RGBX8888: vg_lite_buffer_format = 1026;
pub const vg_lite_buffer_format_VG_LITE_BGRX8888: vg_lite_buffer_format = 1027;
pub const vg_lite_buffer_format_VG_LITE_RGB565: vg_lite_buffer_format = 1028;
pub const vg_lite_buffer_format_VG_LITE_BGR565: vg_lite_buffer_format = 1029;
pub const vg_lite_buffer_format_VG_LITE_RGBA4444: vg_lite_buffer_format = 1030;
pub const vg_lite_buffer_format_VG_LITE_BGRA4444: vg_lite_buffer_format = 1031;
pub const vg_lite_buffer_format_VG_LITE_BGRA5551: vg_lite_buffer_format = 1032;
pub const vg_lite_buffer_format_VG_LITE_A4: vg_lite_buffer_format = 1033;
pub const vg_lite_buffer_format_VG_LITE_A8: vg_lite_buffer_format = 1034;
pub const vg_lite_buffer_format_VG_LITE_L8: vg_lite_buffer_format = 1035;
pub const vg_lite_buffer_format_VG_LITE_YUYV: vg_lite_buffer_format = 1036;
pub const vg_lite_buffer_format_VG_LITE_YUY2: vg_lite_buffer_format = 1037;
pub const vg_lite_buffer_format_VG_LITE_ANV12: vg_lite_buffer_format = 1038;
pub const vg_lite_buffer_format_VG_LITE_AYUY2: vg_lite_buffer_format = 1039;
pub const vg_lite_buffer_format_VG_LITE_NV12: vg_lite_buffer_format = 1040;
pub const vg_lite_buffer_format_VG_LITE_YV12: vg_lite_buffer_format = 1041;
pub const vg_lite_buffer_format_VG_LITE_YV24: vg_lite_buffer_format = 1042;
pub const vg_lite_buffer_format_VG_LITE_YV16: vg_lite_buffer_format = 1043;
pub const vg_lite_buffer_format_VG_LITE_NV16: vg_lite_buffer_format = 1044;
pub const vg_lite_buffer_format_VG_LITE_YUY2_TILED: vg_lite_buffer_format = 1045;
pub const vg_lite_buffer_format_VG_LITE_NV12_TILED: vg_lite_buffer_format = 1046;
pub const vg_lite_buffer_format_VG_LITE_ANV12_TILED: vg_lite_buffer_format = 1047;
pub const vg_lite_buffer_format_VG_LITE_AYUY2_TILED: vg_lite_buffer_format = 1048;
pub const vg_lite_buffer_format_VG_LITE_RGBA2222: vg_lite_buffer_format = 1049;
pub const vg_lite_buffer_format_VG_LITE_BGRA2222: vg_lite_buffer_format = 1050;
pub const vg_lite_buffer_format_VG_LITE_ABGR2222: vg_lite_buffer_format = 1051;
pub const vg_lite_buffer_format_VG_LITE_ARGB2222: vg_lite_buffer_format = 1052;
pub const vg_lite_buffer_format_VG_LITE_ABGR4444: vg_lite_buffer_format = 1053;
pub const vg_lite_buffer_format_VG_LITE_ARGB4444: vg_lite_buffer_format = 1054;
pub const vg_lite_buffer_format_VG_LITE_ABGR8888: vg_lite_buffer_format = 1055;
pub const vg_lite_buffer_format_VG_LITE_ARGB8888: vg_lite_buffer_format = 1056;
pub const vg_lite_buffer_format_VG_LITE_ABGR1555: vg_lite_buffer_format = 1057;
pub const vg_lite_buffer_format_VG_LITE_RGBA5551: vg_lite_buffer_format = 1058;
pub const vg_lite_buffer_format_VG_LITE_ARGB1555: vg_lite_buffer_format = 1059;
pub const vg_lite_buffer_format_VG_LITE_XBGR8888: vg_lite_buffer_format = 1060;
pub const vg_lite_buffer_format_VG_LITE_XRGB8888: vg_lite_buffer_format = 1061;
pub const vg_lite_buffer_format_VG_LITE_RGBA8888_ETC2_EAC: vg_lite_buffer_format = 1062;
pub const vg_lite_buffer_format_VG_LITE_RGB888: vg_lite_buffer_format = 1063;
pub const vg_lite_buffer_format_VG_LITE_BGR888: vg_lite_buffer_format = 1064;
pub const vg_lite_buffer_format_VG_LITE_ABGR8565: vg_lite_buffer_format = 1065;
pub const vg_lite_buffer_format_VG_LITE_BGRA5658: vg_lite_buffer_format = 1066;
pub const vg_lite_buffer_format_VG_LITE_ARGB8565: vg_lite_buffer_format = 1067;
pub const vg_lite_buffer_format_VG_LITE_RGBA5658: vg_lite_buffer_format = 1068;
pub const vg_lite_buffer_format_VG_LITE_ABGR8565_PLANAR: vg_lite_buffer_format = 1069;
pub const vg_lite_buffer_format_VG_LITE_BGRA5658_PLANAR: vg_lite_buffer_format = 1070;
pub const vg_lite_buffer_format_VG_LITE_ARGB8565_PLANAR: vg_lite_buffer_format = 1071;
pub const vg_lite_buffer_format_VG_LITE_RGBA5658_PLANAR: vg_lite_buffer_format = 1072;
pub const vg_lite_buffer_format_VG_LITE_INDEX_1: vg_lite_buffer_format = 2048;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_2: vg_lite_buffer_format = 2049;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_4: vg_lite_buffer_format = 2050;
#[doc = " Indexed format."]
pub const vg_lite_buffer_format_VG_LITE_INDEX_8: vg_lite_buffer_format = 2051;
pub type vg_lite_buffer_format = ::std::os::raw::c_uint;
pub use self::vg_lite_buffer_format as vg_lite_buffer_format_t;
pub const vg_lite_swizzle_VG_LITE_SWIZZLE_UV: vg_lite_swizzle = 0;
pub const vg_lite_swizzle_VG_LITE_SWIZZLE_VU: vg_lite_swizzle = 1;
pub type vg_lite_swizzle = ::std::os::raw::c_uint;
pub use self::vg_lite_swizzle as vg_lite_swizzle_t;
pub const vg_lite_yuv2rgb_VG_LITE_YUV601: vg_lite_yuv2rgb = 0;
pub const vg_lite_yuv2rgb_VG_LITE_YUV709: vg_lite_yuv2rgb = 1;
pub type vg_lite_yuv2rgb = ::std::os::raw::c_uint;
pub use self::vg_lite_yuv2rgb as vg_lite_yuv2rgb_t;
pub const vg_lite_buffer_layout_VG_LITE_LINEAR: vg_lite_buffer_layout = 0;
pub const vg_lite_buffer_layout_VG_LITE_TILED: vg_lite_buffer_layout = 1;
pub type vg_lite_buffer_layout = ::std::os::raw::c_uint;
pub use self::vg_lite_buffer_layout as vg_lite_buffer_layout_t;
pub const vg_lite_image_mode_VG_LITE_ZERO: vg_lite_image_mode = 0;
pub const vg_lite_image_mode_VG_LITE_NORMAL_IMAGE_MODE: vg_lite_image_mode = 7936;
pub const vg_lite_image_mode_VG_LITE_MULTIPLY_IMAGE_MODE: vg_lite_image_mode = 7937;
pub const vg_lite_image_mode_VG_LITE_STENCIL_MODE: vg_lite_image_mode = 7938;
pub const vg_lite_image_mode_VG_LITE_NONE_IMAGE_MODE: vg_lite_image_mode = 7939;
pub const vg_lite_image_mode_VG_LITE_RECOLOR_MODE: vg_lite_image_mode = 7940;
pub type vg_lite_image_mode = ::std::os::raw::c_uint;
pub use self::vg_lite_image_mode as vg_lite_image_mode_t;
pub const vg_lite_transparency_VG_LITE_IMAGE_OPAQUE: vg_lite_transparency = 0;
pub const vg_lite_transparency_VG_LITE_IMAGE_TRANSPARENT: vg_lite_transparency = 1;
pub type vg_lite_transparency = ::std::os::raw::c_uint;
pub use self::vg_lite_transparency as vg_lite_transparency_t;
pub const vg_lite_blend_VG_LITE_BLEND_NONE: vg_lite_blend = 8192;
#[doc = " S, i.e. no blending."]
pub const vg_lite_blend_VG_LITE_BLEND_SRC_OVER: vg_lite_blend = 8193;
#[doc = " S + (1 - Sa) * D"]
pub const vg_lite_blend_VG_LITE_BLEND_DST_OVER: vg_lite_blend = 8194;
#[doc = " (1 - Da) * S + D"]
pub const vg_lite_blend_VG_LITE_BLEND_SRC_IN: vg_lite_blend = 8195;
#[doc = " Da * S"]
pub const vg_lite_blend_VG_LITE_BLEND_DST_IN: vg_lite_blend = 8196;
#[doc = " Sa * D"]
pub const vg_lite_blend_VG_LITE_BLEND_MULTIPLY: vg_lite_blend = 8197;
#[doc = " S * (1 - Da) + D * (1 - Sa) + S * D"]
pub const vg_lite_blend_VG_LITE_BLEND_SCREEN: vg_lite_blend = 8198;
#[doc = " S + D - S * D"]
pub const vg_lite_blend_VG_LITE_BLEND_DARKEN: vg_lite_blend = 8199;
#[doc = " min(SrcOver, DstOver)"]
pub const vg_lite_blend_VG_LITE_BLEND_LIGHTEN: vg_lite_blend = 8200;
#[doc = " max(SrcOver, DstOver)"]
pub const vg_lite_blend_VG_LITE_BLEND_ADDITIVE: vg_lite_blend = 8201;
#[doc = " S + D"]
pub const vg_lite_blend_VG_LITE_BLEND_SUBTRACT: vg_lite_blend = 8202;
#[doc = " D * (1 - S)"]
pub const vg_lite_blend_VG_LITE_BLEND_SUBTRACT_LVGL: vg_lite_blend = 8203;
#[doc = " D - S"]
pub const vg_lite_blend_VG_LITE_BLEND_NORMAL_LVGL: vg_lite_blend = 8204;
#[doc = " S * Sa + (1 - Sa) * D"]
pub const vg_lite_blend_VG_LITE_BLEND_ADDITIVE_LVGL: vg_lite_blend = 8205;
#[doc = " (S + D) * Sa + D * (1 - Sa)"]
pub const vg_lite_blend_VG_LITE_BLEND_MULTIPLY_LVGL: vg_lite_blend = 8206;
#[doc = " (S * D) * Sa + D * (1 - Sa)"]
pub const vg_lite_blend_VG_LITE_BLEND_PREMULTIPLY_SRC_OVER: vg_lite_blend = 8207;
pub type vg_lite_blend = ::std::os::raw::c_uint;
pub use self::vg_lite_blend as vg_lite_blend_t;
pub const vg_lite_fill_VG_LITE_FILL_EVEN_ODD: vg_lite_fill = 6400;
#[doc = " A pixel is drawn it it crosses an odd number of path pixels."]
pub const vg_lite_fill_VG_LITE_FILL_NON_ZERO: vg_lite_fill = 6401;
pub type vg_lite_fill = ::std::os::raw::c_uint;
pub use self::vg_lite_fill as vg_lite_fill_t;
pub const vg_lite_global_alpha_VG_LITE_NORMAL: vg_lite_global_alpha = 0;
#[doc = " Use original src/dst alpha value."]
pub const vg_lite_global_alpha_VG_LITE_GLOBAL: vg_lite_global_alpha = 1;
#[doc = " Use global src/dst alpha value to replace original src/dst alpha value."]
pub const vg_lite_global_alpha_VG_LITE_SCALED: vg_lite_global_alpha = 2;
pub type vg_lite_global_alpha = ::std::os::raw::c_uint;
pub use self::vg_lite_global_alpha as vg_lite_global_alpha_t;
pub const vg_lite_filter_VG_LITE_FILTER_POINT: vg_lite_filter = 0;
#[doc = " Fetch the nearest image pixel."]
pub const vg_lite_filter_VG_LITE_FILTER_LINEAR: vg_lite_filter = 4096;
#[doc = " Used for linear paint."]
pub const vg_lite_filter_VG_LITE_FILTER_BI_LINEAR: vg_lite_filter = 8192;
#[doc = " Use a 2x2 box around the image pixel and perform an interpolation."]
pub const vg_lite_filter_VG_LITE_FILTER_GAUSSIAN: vg_lite_filter = 12288;
pub type vg_lite_filter = ::std::os::raw::c_uint;
pub use self::vg_lite_filter as vg_lite_filter_t;
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_COLOR: vg_lite_pattern_mode = 7424;
#[doc = " Pixel outside the bounds of sourceimage should be taken as the color"]
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_PAD: vg_lite_pattern_mode = 7425;
#[doc = " Pixel outside the bounds of sourceimage should be taken as having the same color as the closest edge pixel"]
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_REPEAT: vg_lite_pattern_mode = 7426;
#[doc = " Pixel outside the bounds of sourceimage should be repeated indefinitely in all directions"]
pub const vg_lite_pattern_mode_VG_LITE_PATTERN_REFLECT: vg_lite_pattern_mode = 7427;
pub type vg_lite_pattern_mode = ::std::os::raw::c_uint;
pub use self::vg_lite_pattern_mode as vg_lite_pattern_mode_t;
pub const vg_lite_gradient_spreadmode_t_VG_LITE_GRADIENT_SPREAD_FILL:
    vg_lite_gradient_spreadmode_t = 0;
pub const vg_lite_gradient_spreadmode_t_VG_LITE_GRADIENT_SPREAD_PAD: vg_lite_gradient_spreadmode_t =
    7168;
pub const vg_lite_gradient_spreadmode_t_VG_LITE_GRADIENT_SPREAD_REPEAT:
    vg_lite_gradient_spreadmode_t = 7169;
pub const vg_lite_gradient_spreadmode_t_VG_LITE_GRADIENT_SPREAD_REFLECT:
    vg_lite_gradient_spreadmode_t = 7170;
pub type vg_lite_gradient_spreadmode_t = ::std::os::raw::c_uint;
pub const vg_lite_compress_mode_VG_LITE_DEC_DISABLE: vg_lite_compress_mode = 0;
#[doc = " disable compress"]
pub const vg_lite_compress_mode_VG_LITE_DEC_NON_SAMPLE: vg_lite_compress_mode = 1;
#[doc = " compress ratio is 1.6 if use ARGB8888, compress ratio is 2 if use XRGB8888"]
pub const vg_lite_compress_mode_VG_LITE_DEC_HSAMPLE: vg_lite_compress_mode = 2;
#[doc = " compress ratio is 2 if use ARGB8888, compress ratio is 2.6 if use XRGB8888"]
pub const vg_lite_compress_mode_VG_LITE_DEC_HV_SAMPLE: vg_lite_compress_mode = 3;
pub type vg_lite_compress_mode = ::std::os::raw::c_uint;
pub use self::vg_lite_compress_mode as vg_lite_compress_mode_t;
pub const vg_lite_path_type_VG_LITE_DRAW_ZERO: vg_lite_path_type = 0;
pub const vg_lite_path_type_VG_LITE_DRAW_STROKE_PATH: vg_lite_path_type = 1;
pub const vg_lite_path_type_VG_LITE_DRAW_FILL_PATH: vg_lite_path_type = 2;
pub const vg_lite_path_type_VG_LITE_DRAW_FILL_STROKE_PATH: vg_lite_path_type = 3;
pub type vg_lite_path_type = ::std::os::raw::c_uint;
pub use self::vg_lite_path_type as vg_lite_path_type_t;
pub const vg_lite_cap_style_VG_LITE_CAP_BUTT: vg_lite_cap_style = 5888;
pub const vg_lite_cap_style_VG_LITE_CAP_ROUND: vg_lite_cap_style = 5889;
pub const vg_lite_cap_style_VG_LITE_CAP_SQUARE: vg_lite_cap_style = 5890;
pub type vg_lite_cap_style = ::std::os::raw::c_uint;
pub use self::vg_lite_cap_style as vg_lite_cap_style_t;
pub const vg_lite_join_style_VG_LITE_JOIN_MITER: vg_lite_join_style = 6144;
pub const vg_lite_join_style_VG_LITE_JOIN_ROUND: vg_lite_join_style = 6145;
pub const vg_lite_join_style_VG_LITE_JOIN_BEVEL: vg_lite_join_style = 6146;
pub type vg_lite_join_style = ::std::os::raw::c_uint;
pub use self::vg_lite_join_style as vg_lite_join_style_t;
pub const vg_lite_mask_operation_VG_LITE_CLEAR_MASK: vg_lite_mask_operation = 5376;
#[doc = " Set all dest mask values to 0"]
pub const vg_lite_mask_operation_VG_LITE_FILL_MASK: vg_lite_mask_operation = 5377;
#[doc = " Set all dest mask values to 1"]
pub const vg_lite_mask_operation_VG_LITE_SET_MASK: vg_lite_mask_operation = 5378;
#[doc = " Copy from src masklayer to dest masklayer."]
pub const vg_lite_mask_operation_VG_LITE_UNION_MASK: vg_lite_mask_operation = 5379;
#[doc = " Replace dest masklayer by its union with src masklayer."]
pub const vg_lite_mask_operation_VG_LITE_INTERSECT_MASK: vg_lite_mask_operation = 5380;
#[doc = " Replace dest masklayer by its intersection with src masklayer."]
pub const vg_lite_mask_operation_VG_LITE_SUBTRACT_MASK: vg_lite_mask_operation = 5381;
pub type vg_lite_mask_operation = ::std::os::raw::c_uint;
pub use self::vg_lite_mask_operation as vg_lite_mask_operation_t;
pub const vg_lite_orientation_VG_LITE_ORIENTATION_TOP_BOTTOM: vg_lite_orientation = 0;
pub const vg_lite_orientation_VG_LITE_ORIENTATION_BOTTOM_TOP: vg_lite_orientation = 1;
pub type vg_lite_orientation = ::std::os::raw::c_uint;
pub use self::vg_lite_orientation as vg_lite_orientation_t;
pub const vg_lite_gamma_conversion_VG_LITE_GAMMA_NO_CONVERSION: vg_lite_gamma_conversion = 0;
#[doc = " Leave color as is."]
pub const vg_lite_gamma_conversion_VG_LITE_GAMMA_LINEAR: vg_lite_gamma_conversion = 1;
#[doc = " Convert from sRGB to linear space."]
pub const vg_lite_gamma_conversion_VG_LITE_GAMMA_NON_LINEAR: vg_lite_gamma_conversion = 2;
pub type vg_lite_gamma_conversion = ::std::os::raw::c_uint;
pub use self::vg_lite_gamma_conversion as vg_lite_gamma_conversion_t;
pub const vg_lite_index_endian_VG_LITE_INDEX_LITTLE_ENDIAN: vg_lite_index_endian = 0;
#[doc = " Parse the index pixel from low to high,\n when using index1, the parsing order is bit0~bit7.\n when using index2, the parsing order is bit0:1,bit2:3,bit4:5.bit6:7.\n when using index4, the parsing order is bit0:3,bit4:7."]
pub const vg_lite_index_endian_VG_LITE_INDEX_BIG_ENDIAN: vg_lite_index_endian = 1;
pub type vg_lite_index_endian = ::std::os::raw::c_uint;
pub use self::vg_lite_index_endian as vg_lite_index_endian_t;
pub const vg_lite_map_flag_VG_LITE_MAP_USER_MEMORY: vg_lite_map_flag = 0;
pub const vg_lite_map_flag_VG_LITE_MAP_DMABUF: vg_lite_map_flag = 1;
pub type vg_lite_map_flag = ::std::os::raw::c_uint;
pub use self::vg_lite_map_flag as vg_lite_map_flag_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_info {
    pub api_version: vg_lite_uint32_t,
    pub header_version: vg_lite_uint32_t,
    pub release_version: vg_lite_uint32_t,
    pub reserved: vg_lite_uint32_t,
}
#[test]
fn bindgen_test_layout_vg_lite_info() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_info>(),
        16usize,
        concat!("Size of: ", stringify!(vg_lite_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(header_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(release_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_info),
            "::",
            stringify!(reserved)
        )
    );
}
pub type vg_lite_info_t = vg_lite_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_point {
    pub x: vg_lite_int32_t,
    pub y: vg_lite_int32_t,
}
#[test]
fn bindgen_test_layout_vg_lite_point() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_point>(),
        8usize,
        concat!("Size of: ", stringify!(vg_lite_point))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_point>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_point),
            "::",
            stringify!(y)
        )
    );
}
pub type vg_lite_point_t = vg_lite_point;
pub type vg_lite_point4_t = [vg_lite_point_t; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_rectangle {
    pub x: vg_lite_int32_t,
    #[doc = " Left coordinate of rectangle."]
    pub y: vg_lite_int32_t,
    #[doc = " Top coordinate of rectangle."]
    pub width: vg_lite_int32_t,
    #[doc = " Width of rectangle."]
    pub height: vg_lite_int32_t,
}
#[test]
fn bindgen_test_layout_vg_lite_rectangle() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_rectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(vg_lite_rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_rectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_rectangle),
            "::",
            stringify!(height)
        )
    );
}
pub type vg_lite_rectangle_t = vg_lite_rectangle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_matrix {
    pub m: [[vg_lite_float_t; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_vg_lite_matrix() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_matrix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_matrix>(),
        36usize,
        concat!("Size of: ", stringify!(vg_lite_matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_matrix),
            "::",
            stringify!(m)
        )
    );
}
pub type vg_lite_matrix_t = vg_lite_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_yuvinfo {
    pub swizzle: vg_lite_swizzle_t,
    #[doc = " UV swizzle."]
    pub yuv2rgb: vg_lite_yuv2rgb_t,
    #[doc = " 601 or 709 conversion standard."]
    pub uv_planar: vg_lite_uint32_t,
    #[doc = " UV(U) planar address."]
    pub v_planar: vg_lite_uint32_t,
    #[doc = " V planar address."]
    pub alpha_planar: vg_lite_uint32_t,
    #[doc = " Alpha planar address."]
    pub uv_stride: vg_lite_uint32_t,
    #[doc = " UV(U) stride."]
    pub v_stride: vg_lite_uint32_t,
    #[doc = " V stride."]
    pub alpha_stride: vg_lite_uint32_t,
    #[doc = " Alpha stride."]
    pub uv_height: vg_lite_uint32_t,
    #[doc = " UV(U) height."]
    pub v_height: vg_lite_uint32_t,
    #[doc = " V height."]
    pub uv_memory: vg_lite_pointer,
    #[doc = " The logical pointer to the UV(U) planar memory."]
    pub v_memory: vg_lite_pointer,
    #[doc = " The logical pointer to the V planar memory."]
    pub uv_handle: vg_lite_pointer,
    #[doc = " The memory handle of the UV(U) planar."]
    pub v_handle: vg_lite_pointer,
}
#[test]
fn bindgen_test_layout_vg_lite_yuvinfo() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_yuvinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_yuvinfo>(),
        72usize,
        concat!("Size of: ", stringify!(vg_lite_yuvinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_yuvinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_yuvinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swizzle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(swizzle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv2rgb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(yuv2rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_planar) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_planar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_planar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(alpha_planar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_stride) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_stride) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_stride) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(alpha_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_height) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_memory) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_memory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_handle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(uv_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_handle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_yuvinfo),
            "::",
            stringify!(v_handle)
        )
    );
}
pub type vg_lite_yuvinfo_t = vg_lite_yuvinfo;
pub type vg_lite_path_point_ptr = *mut vg_lite_path_point;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_path_point {
    pub x: vg_lite_float_t,
    pub y: vg_lite_float_t,
    pub flatten_flag: vg_lite_uint8_t,
    pub curve_type: vg_lite_uint8_t,
    pub tangentX: vg_lite_float_t,
    pub tangentY: vg_lite_float_t,
    pub length: vg_lite_float_t,
    pub next: vg_lite_path_point_ptr,
    pub prev: vg_lite_path_point_ptr,
}
#[test]
fn bindgen_test_layout_vg_lite_path_point() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_path_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_path_point>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_path_point))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_path_point>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_path_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flatten_flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(flatten_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curve_type) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(curve_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangentX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(tangentX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangentY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(tangentY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_point),
            "::",
            stringify!(prev)
        )
    );
}
pub type vg_lite_path_point_t = vg_lite_path_point;
pub type vg_lite_sub_path_ptr = *mut vg_lite_sub_path;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_sub_path {
    pub next: vg_lite_sub_path_ptr,
    pub point_count: vg_lite_uint32_t,
    pub point_list: vg_lite_path_point_ptr,
    pub end_point: vg_lite_path_point_ptr,
    pub closed: vg_lite_uint8_t,
    pub length: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_sub_path() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_sub_path> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_sub_path>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_sub_path))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_sub_path>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_sub_path))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(point_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(point_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_point) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(end_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_sub_path),
            "::",
            stringify!(length)
        )
    );
}
pub type vg_lite_sub_path_t = vg_lite_sub_path;
pub type vg_lite_path_list_ptr = *mut vg_lite_path_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_path_list {
    pub path_points: vg_lite_path_point_ptr,
    pub path_end: vg_lite_path_point_ptr,
    pub point_count: vg_lite_uint32_t,
    pub next: vg_lite_path_list_ptr,
    pub closed: vg_lite_uint8_t,
}
#[test]
fn bindgen_test_layout_vg_lite_path_list() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_path_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_path_list>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_path_list))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_path_list>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_path_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_list),
            "::",
            stringify!(path_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_list),
            "::",
            stringify!(path_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_list),
            "::",
            stringify!(point_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path_list),
            "::",
            stringify!(closed)
        )
    );
}
pub type vg_lite_path_list_t = vg_lite_path_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_stroke {
    pub cap_style: vg_lite_cap_style_t,
    pub join_style: vg_lite_join_style_t,
    pub line_width: vg_lite_float_t,
    pub miter_limit: vg_lite_float_t,
    pub dash_pattern: *mut vg_lite_float_t,
    pub pattern_count: vg_lite_uint32_t,
    pub dash_phase: vg_lite_float_t,
    pub dash_length: vg_lite_float_t,
    pub dash_index: vg_lite_uint32_t,
    pub half_width: vg_lite_float_t,
    pub pattern_length: vg_lite_float_t,
    pub miter_square: vg_lite_float_t,
    pub path_points: vg_lite_path_point_ptr,
    pub path_end: vg_lite_path_point_ptr,
    pub point_count: vg_lite_uint32_t,
    pub left_point: vg_lite_path_point_ptr,
    pub right_point: vg_lite_path_point_ptr,
    pub stroke_points: vg_lite_path_point_ptr,
    pub stroke_end: vg_lite_path_point_ptr,
    pub stroke_count: vg_lite_uint32_t,
    pub path_list_divide: vg_lite_path_list_ptr,
    pub cur_list: vg_lite_path_list_ptr,
    pub add_end: vg_lite_uint8_t,
    pub stroke_paths: vg_lite_sub_path_ptr,
    pub last_stroke: vg_lite_sub_path_ptr,
    pub need_swing: vg_lite_uint8_t,
    pub swing_handling: vg_lite_uint32_t,
    pub swing_ccw: vg_lite_uint8_t,
    pub swing_deltax: vg_lite_float_t,
    pub swing_deltay: vg_lite_float_t,
    pub swing_start: vg_lite_path_point_ptr,
    pub swing_stroke: vg_lite_path_point_ptr,
    pub swing_length: vg_lite_float_t,
    pub swing_centlen: vg_lite_float_t,
    pub swing_count: vg_lite_uint32_t,
    pub stroke_length: vg_lite_float_t,
    pub stroke_size: vg_lite_uint32_t,
    pub fattened: vg_lite_uint8_t,
    pub closed: vg_lite_uint8_t,
}
#[test]
fn bindgen_test_layout_vg_lite_stroke() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_stroke> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_stroke>(),
        224usize,
        concat!("Size of: ", stringify!(vg_lite_stroke))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_stroke>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_stroke))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_style) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miter_limit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(miter_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_pattern) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(dash_pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(pattern_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_phase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(dash_phase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(dash_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dash_index) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(dash_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).half_width) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(half_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_length) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(pattern_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miter_square) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(miter_square)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_points) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(path_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(path_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(point_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left_point) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(left_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right_point) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(right_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_points) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_end) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_count) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_list_divide) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(path_list_divide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(cur_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_end) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(add_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_paths) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_stroke) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(last_stroke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_swing) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(need_swing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_handling) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_handling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_ccw) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_ccw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_deltax) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_deltax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_deltay) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_deltay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_start) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_stroke) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_stroke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_length) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_centlen) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_centlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swing_count) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(swing_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_length) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_size) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(stroke_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fattened) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(fattened)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed) as usize - ptr as usize },
        221usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_stroke),
            "::",
            stringify!(closed)
        )
    );
}
pub type vg_lite_stroke_t = vg_lite_stroke;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_fc_buffer {
    pub width: vg_lite_int32_t,
    #[doc = " Width of the buffer in pixels."]
    pub height: vg_lite_int32_t,
    #[doc = " height of the buffer in pixels."]
    pub stride: vg_lite_int32_t,
    #[doc = " The number of bytes to move from one line in the buffer to the next line."]
    pub handle: vg_lite_pointer,
    #[doc = " The memory handle of the buffer's memory as allocated by the VGLite kernel."]
    pub memory: vg_lite_pointer,
    #[doc = " The logical pointer to the buffer's memory for the CPU."]
    pub address: vg_lite_uint32_t,
    #[doc = " The address to the buffer's memory for the hardware."]
    pub color: vg_lite_uint32_t,
}
#[test]
fn bindgen_test_layout_vg_lite_fc_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_fc_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_fc_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(vg_lite_fc_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_fc_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_fc_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_fc_buffer),
            "::",
            stringify!(color)
        )
    );
}
pub type vg_lite_fc_buffer_t = vg_lite_fc_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_buffer {
    pub width: vg_lite_int32_t,
    #[doc = " Width of the buffer in pixels."]
    pub height: vg_lite_int32_t,
    #[doc = " Height of the buffer in pixels."]
    pub stride: vg_lite_int32_t,
    #[doc = " The number of bytes to move from one line in the buffer to the next line."]
    pub tiled: vg_lite_buffer_layout_t,
    #[doc = " Indicating the buffer memory layout is linear or tiled."]
    pub format: vg_lite_buffer_format_t,
    #[doc = " The pixel format of the buffer."]
    pub handle: vg_lite_pointer,
    #[doc = " The memory handle of the buffer's memory as allocated by the VGLite kernel."]
    pub memory: vg_lite_pointer,
    #[doc = " The logical pointer to the buffer's memory for the CPU."]
    pub address: vg_lite_uint32_t,
    #[doc = " The address to the buffer's memory for the hardware."]
    pub yuv: vg_lite_yuvinfo_t,
    #[doc = " The yuv format details."]
    pub image_mode: vg_lite_image_mode_t,
    #[doc = " The blit image mode."]
    pub transparency_mode: vg_lite_transparency_t,
    #[doc = " image transparency mode."]
    pub fc_enable: vg_lite_int8_t,
    #[doc = " enable im fastclear."]
    pub fc_buffer: [vg_lite_fc_buffer_t; 3usize],
    #[doc = " 3 fastclear buffers,reserved YUV format."]
    pub compress_mode: vg_lite_compress_mode_t,
    #[doc = " Refer to the definition by vg_lite_compress_mode_t."]
    pub index_endian: vg_lite_index_endian_t,
}
#[test]
fn bindgen_test_layout_vg_lite_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_buffer>(),
        264usize,
        concat!("Size of: ", stringify!(vg_lite_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(tiled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yuv) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(yuv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_mode) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(image_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transparency_mode) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(transparency_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc_enable) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(fc_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fc_buffer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(fc_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compress_mode) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(compress_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index_endian) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_buffer),
            "::",
            stringify!(index_endian)
        )
    );
}
pub type vg_lite_buffer_t = vg_lite_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_hw_memory {
    pub handle: vg_lite_pointer,
    #[doc = " gpu memory object handle."]
    pub memory: vg_lite_pointer,
    #[doc = " logical memory address."]
    pub address: vg_lite_uint32_t,
    #[doc = " GPU memory address."]
    pub bytes: vg_lite_uint32_t,
    #[doc = " Size of memory."]
    pub property: vg_lite_uint32_t,
}
#[test]
fn bindgen_test_layout_vg_lite_hw_memory() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_hw_memory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_hw_memory>(),
        32usize,
        concat!("Size of: ", stringify!(vg_lite_hw_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_hw_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_hw_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_hw_memory),
            "::",
            stringify!(property)
        )
    );
}
pub type vg_lite_hw_memory_t = vg_lite_hw_memory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_path {
    pub bounding_box: [vg_lite_float_t; 4usize],
    #[doc = " Bounding box specified as left, top, right, and bottom."]
    pub quality: vg_lite_quality_t,
    #[doc = " Quality hint for the path."]
    pub format: vg_lite_format_t,
    #[doc = " Coordinate format."]
    pub uploaded: vg_lite_hw_memory_t,
    #[doc = " Path data that has been upload into GPU addressable memory."]
    pub path_length: vg_lite_uint32_t,
    #[doc = " Number of bytes in the path data."]
    pub path: vg_lite_pointer,
    #[doc = " Pointer to the physical description of the path."]
    pub path_changed: vg_lite_int8_t,
    #[doc = " Indicate whether path data is synced with command buffer (uploaded) or not."]
    pub pdata_internal: vg_lite_int8_t,
    #[doc = " Indicate whether path data memory is allocated by driver."]
    pub path_type: vg_lite_path_type_t,
    #[doc = " Refer to the definition by vg_lite_path_type_t."]
    pub stroke: *mut vg_lite_stroke_t,
    #[doc = " Pointer to a vg_lite_stroke_t structure."]
    pub stroke_path: vg_lite_pointer,
    #[doc = " Pointer to the physical description of the stroke path."]
    pub stroke_size: vg_lite_uint32_t,
    #[doc = " Number of bytes in the stroke path data."]
    pub stroke_color: vg_lite_color_t,
    #[doc = " The stroke path fill color."]
    pub add_end: vg_lite_int8_t,
}
#[test]
fn bindgen_test_layout_vg_lite_path() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_path> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_path>(),
        112usize,
        concat!("Size of: ", stringify!(vg_lite_path))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_path>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_path))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounding_box) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(bounding_box)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uploaded) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(uploaded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_length) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_changed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdata_internal) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(pdata_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_type) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(path_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(stroke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_path) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(stroke_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(stroke_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stroke_color) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(stroke_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_end) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_path),
            "::",
            stringify!(add_end)
        )
    );
}
pub type vg_lite_path_t = vg_lite_path;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_color_ramp {
    pub stop: vg_lite_float_t,
    #[doc = " Value for the color stop."]
    pub red: vg_lite_float_t,
    #[doc = " Red color channel value for the color stop."]
    pub green: vg_lite_float_t,
    #[doc = " Green color channel value for the color stop."]
    pub blue: vg_lite_float_t,
    #[doc = " Blue color channel value for the color stop."]
    pub alpha: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_color_ramp() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_color_ramp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_color_ramp>(),
        20usize,
        concat!("Size of: ", stringify!(vg_lite_color_ramp))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_color_ramp>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_color_ramp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_ramp),
            "::",
            stringify!(alpha)
        )
    );
}
pub type vg_lite_color_ramp_t = vg_lite_color_ramp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_linear_gradient_parameter {
    pub X0: vg_lite_float_t,
    pub Y0: vg_lite_float_t,
    pub X1: vg_lite_float_t,
    pub Y1: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_linear_gradient_parameter() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_linear_gradient_parameter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_linear_gradient_parameter>(),
        16usize,
        concat!("Size of: ", stringify!(vg_lite_linear_gradient_parameter))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_linear_gradient_parameter>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vg_lite_linear_gradient_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient_parameter),
            "::",
            stringify!(X0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient_parameter),
            "::",
            stringify!(Y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient_parameter),
            "::",
            stringify!(X1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient_parameter),
            "::",
            stringify!(Y1)
        )
    );
}
pub type vg_lite_linear_gradient_parameter_t = vg_lite_linear_gradient_parameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_radial_gradient_parameter {
    pub cx: vg_lite_float_t,
    #[doc = " x coordinate of the center point."]
    pub cy: vg_lite_float_t,
    #[doc = " y coordinate of the center point."]
    pub r: vg_lite_float_t,
    #[doc = " radius."]
    pub fx: vg_lite_float_t,
    #[doc = " x coordinate of the focal point."]
    pub fy: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_radial_gradient_parameter() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_radial_gradient_parameter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_radial_gradient_parameter>(),
        20usize,
        concat!("Size of: ", stringify!(vg_lite_radial_gradient_parameter))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_radial_gradient_parameter>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vg_lite_radial_gradient_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient_parameter),
            "::",
            stringify!(fy)
        )
    );
}
pub type vg_lite_radial_gradient_parameter_t = vg_lite_radial_gradient_parameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_linear_gradient {
    pub colors: [vg_lite_uint32_t; 16usize],
    #[doc = " Colors for stops."]
    pub count: vg_lite_uint32_t,
    #[doc = " Count of colors, up to 16."]
    pub stops: [vg_lite_uint32_t; 16usize],
    #[doc = " Color stops, value from 0 to 255."]
    pub matrix: vg_lite_matrix_t,
    #[doc = " The matrix to transform the gradient."]
    pub image: vg_lite_buffer_t,
}
#[test]
fn bindgen_test_layout_vg_lite_linear_gradient() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_linear_gradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_linear_gradient>(),
        432usize,
        concat!("Size of: ", stringify!(vg_lite_linear_gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_linear_gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_linear_gradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stops) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(stops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_linear_gradient),
            "::",
            stringify!(image)
        )
    );
}
pub type vg_lite_linear_gradient_t = vg_lite_linear_gradient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_ext_linear_gradient {
    pub count: vg_lite_uint32_t,
    #[doc = " Count of colors, up to 256."]
    pub matrix: vg_lite_matrix_t,
    #[doc = " The matrix to transform the gradient."]
    pub image: vg_lite_buffer_t,
    #[doc = " The image for rendering as gradient pattern."]
    pub linear_grad: vg_lite_linear_gradient_parameter_t,
    #[doc = "  Include center point,focal point and radius."]
    pub ramp_length: vg_lite_uint32_t,
    #[doc = " Color ramp for gradient paints provided to driver."]
    pub color_ramp: [vg_lite_color_ramp_t; 256usize],
    pub converted_length: vg_lite_uint32_t,
    #[doc = " Converted internal color ramp."]
    pub converted_ramp: [vg_lite_color_ramp_t; 258usize],
    pub pre_multiplied: vg_lite_uint8_t,
    #[doc = " If color values of color_ramp[] are multiply by alpha value of color_ramp[]."]
    pub spread_mode: vg_lite_gradient_spreadmode_t,
}
#[test]
fn bindgen_test_layout_vg_lite_ext_linear_gradient() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_ext_linear_gradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_ext_linear_gradient>(),
        10616usize,
        concat!("Size of: ", stringify!(vg_lite_ext_linear_gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_ext_linear_gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_ext_linear_gradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_grad) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(linear_grad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ramp_length) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(ramp_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_ramp) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(color_ramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).converted_length) as usize - ptr as usize },
        5444usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(converted_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).converted_ramp) as usize - ptr as usize },
        5448usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(converted_ramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_multiplied) as usize - ptr as usize },
        10608usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(pre_multiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spread_mode) as usize - ptr as usize },
        10612usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_ext_linear_gradient),
            "::",
            stringify!(spread_mode)
        )
    );
}
pub type vg_lite_ext_linear_gradient_t = vg_lite_ext_linear_gradient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_radial_gradient {
    pub count: vg_lite_uint32_t,
    #[doc = " Count of colors, up to 256."]
    pub matrix: vg_lite_matrix_t,
    #[doc = " The matrix to transform the gradient."]
    pub image: vg_lite_buffer_t,
    #[doc = " The image for rendering as gradient pattern."]
    pub radial_grad: vg_lite_radial_gradient_parameter_t,
    #[doc = "  Include center point,focal point and radius."]
    pub ramp_length: vg_lite_uint32_t,
    #[doc = " Color ramp for gradient paints provided to the driver."]
    pub color_ramp: [vg_lite_color_ramp_t; 256usize],
    pub converted_length: vg_lite_uint32_t,
    #[doc = " Converted internal color ramp."]
    pub converted_ramp: [vg_lite_color_ramp_t; 258usize],
    pub pre_multiplied: vg_lite_uint8_t,
    #[doc = " If color values of color_ramp[] are multiply by alpha value of color_ramp[]."]
    pub spread_mode: vg_lite_gradient_spreadmode_t,
}
#[test]
fn bindgen_test_layout_vg_lite_radial_gradient() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_radial_gradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_radial_gradient>(),
        10624usize,
        concat!("Size of: ", stringify!(vg_lite_radial_gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_radial_gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(vg_lite_radial_gradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radial_grad) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(radial_grad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ramp_length) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(ramp_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_ramp) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(color_ramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).converted_length) as usize - ptr as usize },
        5448usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(converted_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).converted_ramp) as usize - ptr as usize },
        5452usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(converted_ramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_multiplied) as usize - ptr as usize },
        10612usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(pre_multiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spread_mode) as usize - ptr as usize },
        10616usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_radial_gradient),
            "::",
            stringify!(spread_mode)
        )
    );
}
pub type vg_lite_radial_gradient_t = vg_lite_radial_gradient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_color_key {
    pub enable: vg_lite_uint8_t,
    #[doc = " The color key is effective only when \"enable\" is ture,"]
    pub low_r: vg_lite_uint8_t,
    #[doc = " The R chanel of low_rgb."]
    pub low_g: vg_lite_uint8_t,
    #[doc = " The G chanel of low_rgb."]
    pub low_b: vg_lite_uint8_t,
    #[doc = " The B chanel of low_rgb."]
    pub alpha: vg_lite_uint8_t,
    #[doc = " The alpha channel to replace destination pixel alpha channel."]
    pub hign_r: vg_lite_uint8_t,
    #[doc = " The R chanel of hign_rgb."]
    pub hign_g: vg_lite_uint8_t,
    #[doc = " The G chanel of hign_rgb."]
    pub hign_b: vg_lite_uint8_t,
}
#[test]
fn bindgen_test_layout_vg_lite_color_key() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_color_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_color_key>(),
        8usize,
        concat!("Size of: ", stringify!(vg_lite_color_key))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_color_key>(),
        1usize,
        concat!("Alignment of ", stringify!(vg_lite_color_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_r) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_g) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_b) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(low_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_r) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_g) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hign_b) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_key),
            "::",
            stringify!(hign_b)
        )
    );
}
pub type vg_lite_color_key_t = vg_lite_color_key;
pub type vg_lite_color_key4_t = [vg_lite_color_key_t; 4usize];
pub type vg_lite_pixel_matrix_t = [vg_lite_float_t; 20usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_pixel_channel_enable {
    pub enable_a: vg_lite_uint8_t,
    #[doc = " Enable A channel."]
    pub enable_b: vg_lite_uint8_t,
    #[doc = " Enable B channel."]
    pub enable_g: vg_lite_uint8_t,
    #[doc = " Enable G channel."]
    pub enable_r: vg_lite_uint8_t,
}
#[test]
fn bindgen_test_layout_vg_lite_pixel_channel_enable() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_pixel_channel_enable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_pixel_channel_enable>(),
        4usize,
        concat!("Size of: ", stringify!(vg_lite_pixel_channel_enable))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_pixel_channel_enable>(),
        1usize,
        concat!("Alignment of ", stringify!(vg_lite_pixel_channel_enable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_pixel_channel_enable),
            "::",
            stringify!(enable_a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_b) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_pixel_channel_enable),
            "::",
            stringify!(enable_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_g) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_pixel_channel_enable),
            "::",
            stringify!(enable_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_r) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_pixel_channel_enable),
            "::",
            stringify!(enable_r)
        )
    );
}
pub type vg_lite_pixel_channel_enable_t = vg_lite_pixel_channel_enable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vg_lite_color_transform {
    pub a_scale: vg_lite_float_t,
    pub a_bias: vg_lite_float_t,
    pub r_scale: vg_lite_float_t,
    pub r_bias: vg_lite_float_t,
    pub g_scale: vg_lite_float_t,
    pub g_bias: vg_lite_float_t,
    pub b_scale: vg_lite_float_t,
    pub b_bias: vg_lite_float_t,
}
#[test]
fn bindgen_test_layout_vg_lite_color_transform() {
    const UNINIT: ::std::mem::MaybeUninit<vg_lite_color_transform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vg_lite_color_transform>(),
        32usize,
        concat!("Size of: ", stringify!(vg_lite_color_transform))
    );
    assert_eq!(
        ::std::mem::align_of::<vg_lite_color_transform>(),
        4usize,
        concat!("Alignment of ", stringify!(vg_lite_color_transform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a_scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(a_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a_bias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(a_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(r_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_bias) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(r_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(g_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_bias) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(g_bias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_scale) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(b_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_bias) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vg_lite_color_transform),
            "::",
            stringify!(b_bias)
        )
    );
}
pub type vg_lite_color_transform_t = vg_lite_color_transform;
extern "C" {
    pub fn vg_lite_init(
        tess_width: vg_lite_int32_t,
        tess_height: vg_lite_int32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_close() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_info(info: *mut vg_lite_info_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_product_info(
        name: *mut vg_lite_char,
        chip_id: *mut vg_lite_uint32_t,
        chip_rev: *mut vg_lite_uint32_t,
    ) -> vg_lite_uint32_t;
}
extern "C" {
    pub fn vg_lite_query_feature(feature: vg_lite_feature_t) -> vg_lite_uint32_t;
}
extern "C" {
    pub fn vg_lite_finish() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flush() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_register(
        address: vg_lite_uint32_t,
        result: *mut vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_transform_matrix(
        src: *mut vg_lite_point_t,
        dst: *mut vg_lite_point_t,
        mat: *mut vg_lite_matrix_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_allocate(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_free(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_upload_buffer(
        buffer: *mut vg_lite_buffer_t,
        data: *mut *mut vg_lite_uint8_t,
        stride: *mut vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_map(
        buffer: *mut vg_lite_buffer_t,
        flag: vg_lite_map_flag_t,
        fd: i32,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_unmap(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flush_mapped_buffer(buffer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_clear(
        target: *mut vg_lite_buffer_t,
        rect: *mut vg_lite_rectangle_t,
        color: vg_lite_color_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_blit(
        target: *mut vg_lite_buffer_t,
        source: *mut vg_lite_buffer_t,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_blit_rect(
        target: *mut vg_lite_buffer_t,
        source: *mut vg_lite_buffer_t,
        rect: *mut vg_lite_rectangle_t,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_blit2(
        target: *mut vg_lite_buffer_t,
        source0: *mut vg_lite_buffer_t,
        source1: *mut vg_lite_buffer_t,
        matrix0: *mut vg_lite_matrix_t,
        matrix1: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_draw(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        color: vg_lite_color_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_stroke(
        path: *mut vg_lite_path_t,
        cap_style: vg_lite_cap_style_t,
        join_style: vg_lite_join_style_t,
        line_width: vg_lite_float_t,
        miter_limit: vg_lite_float_t,
        dash_pattern: *mut vg_lite_float_t,
        pattern_count: vg_lite_uint32_t,
        dash_phase: vg_lite_float_t,
        color: vg_lite_color_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_update_stroke(path: *mut vg_lite_path_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_path_type(
        path: *mut vg_lite_path_t,
        path_type: vg_lite_path_type_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_clear_path(path: *mut vg_lite_path_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_upload_path(path: *mut vg_lite_path_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_init_path(
        path: *mut vg_lite_path_t,
        format: vg_lite_format_t,
        quality: vg_lite_quality_t,
        length: vg_lite_uint32_t,
        data: vg_lite_pointer,
        min_x: vg_lite_float_t,
        min_y: vg_lite_float_t,
        max_x: vg_lite_float_t,
        max_y: vg_lite_float_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_init_arc_path(
        path: *mut vg_lite_path_t,
        format: vg_lite_format_t,
        quality: vg_lite_quality_t,
        length: vg_lite_uint32_t,
        data: vg_lite_pointer,
        min_x: vg_lite_float_t,
        min_y: vg_lite_float_t,
        max_x: vg_lite_float_t,
        max_y: vg_lite_float_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_path_length(
        opcode: *mut vg_lite_uint8_t,
        count: vg_lite_uint32_t,
        format: vg_lite_format_t,
    ) -> vg_lite_uint32_t;
}
extern "C" {
    pub fn vg_lite_append_path(
        path: *mut vg_lite_path_t,
        opcode: *mut vg_lite_uint8_t,
        data: vg_lite_pointer,
        seg_count: vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_CLUT(
        count: vg_lite_uint32_t,
        colors: *mut vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_draw_pattern(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        path_matrix: *mut vg_lite_matrix_t,
        pattern_image: *mut vg_lite_buffer_t,
        pattern_matrix: *mut vg_lite_matrix_t,
        blend: vg_lite_blend_t,
        pattern_mode: vg_lite_pattern_mode_t,
        pattern_color: vg_lite_color_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_init_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_clear_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_update_grad(grad: *mut vg_lite_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_grad_matrix(grad: *mut vg_lite_linear_gradient_t) -> *mut vg_lite_matrix_t;
}
extern "C" {
    pub fn vg_lite_set_grad(
        grad: *mut vg_lite_linear_gradient_t,
        count: vg_lite_uint32_t,
        colors: *mut vg_lite_uint32_t,
        stops: *mut vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_draw_grad(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        matrix: *mut vg_lite_matrix_t,
        grad: *mut vg_lite_linear_gradient_t,
        blend: vg_lite_blend_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_clear_linear_grad(grad: *mut vg_lite_ext_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_update_linear_grad(grad: *mut vg_lite_ext_linear_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_linear_grad_matrix(
        grad: *mut vg_lite_ext_linear_gradient_t,
    ) -> *mut vg_lite_matrix_t;
}
extern "C" {
    pub fn vg_lite_set_linear_grad(
        grad: *mut vg_lite_ext_linear_gradient_t,
        count: vg_lite_uint32_t,
        color_ramp: *mut vg_lite_color_ramp_t,
        grad_param: vg_lite_linear_gradient_parameter_t,
        spread_mode: vg_lite_gradient_spreadmode_t,
        pre_mult: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_draw_linear_grad(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        path_matrix: *mut vg_lite_matrix_t,
        grad: *mut vg_lite_ext_linear_gradient_t,
        paint_color: vg_lite_color_t,
        blend: vg_lite_blend_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_clear_radial_grad(grad: *mut vg_lite_radial_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_update_radial_grad(grad: *mut vg_lite_radial_gradient_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_radial_grad_matrix(
        grad: *mut vg_lite_radial_gradient_t,
    ) -> *mut vg_lite_matrix_t;
}
extern "C" {
    pub fn vg_lite_set_radial_grad(
        grad: *mut vg_lite_radial_gradient_t,
        count: vg_lite_uint32_t,
        color_ramp: *mut vg_lite_color_ramp_t,
        grad_param: vg_lite_radial_gradient_parameter_t,
        spread_mode: vg_lite_gradient_spreadmode_t,
        pre_mult: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_draw_radial_grad(
        target: *mut vg_lite_buffer_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        path_matrix: *mut vg_lite_matrix_t,
        grad: *mut vg_lite_radial_gradient_t,
        paint_color: vg_lite_color_t,
        blend: vg_lite_blend_t,
        filter: vg_lite_filter_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_identity(matrix: *mut vg_lite_matrix_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_translate(
        x: vg_lite_float_t,
        y: vg_lite_float_t,
        matrix: *mut vg_lite_matrix_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_scale(
        scale_x: vg_lite_float_t,
        scale_y: vg_lite_float_t,
        matrix: *mut vg_lite_matrix_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_rotate(
        degrees: vg_lite_float_t,
        matrix: *mut vg_lite_matrix_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_scissor(
        x: vg_lite_int32_t,
        y: vg_lite_int32_t,
        right: vg_lite_int32_t,
        bottom: vg_lite_int32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_enable_scissor() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_disable_scissor() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_get_mem_size(size: *mut vg_lite_uint32_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_source_global_alpha(
        alpha_mode: vg_lite_global_alpha_t,
        alpha_value: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_dest_global_alpha(
        alpha_mode: vg_lite_global_alpha_t,
        alpha_value: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_color_key(colorkey: *mut vg_lite_color_key_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_enable_dither() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_disable_dither() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_tess_buffer(
        physical: vg_lite_uint32_t,
        size: vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_command_buffer_size(size: vg_lite_uint32_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_command_buffer(
        physical: vg_lite_uint32_t,
        size: vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_pixel_matrix(
        matrix: *mut vg_lite_float_t,
        channel: *mut vg_lite_pixel_channel_enable_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_gaussian_filter(
        w0: vg_lite_float_t,
        w1: vg_lite_float_t,
        w2: vg_lite_float_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_enable_masklayer() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_disable_masklayer() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_masklayer(masklayer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_destroy_masklayer(masklayer: *mut vg_lite_buffer_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_create_masklayer(
        masklayer: *mut vg_lite_buffer_t,
        width: vg_lite_uint32_t,
        height: vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_fill_masklayer(
        masklayer: *mut vg_lite_buffer_t,
        rect: *mut vg_lite_rectangle_t,
        value: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_blend_masklayer(
        dst: *mut vg_lite_buffer_t,
        src: *mut vg_lite_buffer_t,
        operation: vg_lite_mask_operation_t,
        rect: *mut vg_lite_rectangle_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_render_masklayer(
        masklayer: *mut vg_lite_buffer_t,
        operation: vg_lite_mask_operation_t,
        path: *mut vg_lite_path_t,
        fill_rule: vg_lite_fill_t,
        color: vg_lite_color_t,
        matrix: *mut vg_lite_matrix_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_scissor_rects(
        nums: vg_lite_uint32_t,
        rect: *mut vg_lite_rectangle_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_mirror(orientation: vg_lite_orientation_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_gamma(gamma_value: vg_lite_gamma_conversion_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_premultiply(
        src_premult: vg_lite_uint8_t,
        dst_premult: vg_lite_uint8_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_enable_color_transform() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_disable_color_transform() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_set_color_transform(values: *mut vg_lite_color_transform_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flexa_set_stream(stream_id: vg_lite_uint8_t) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flexa_bg_buffer(
        stream_id: vg_lite_uint8_t,
        buffer: *mut vg_lite_buffer_t,
        seg_count: vg_lite_uint32_t,
        seg_size: vg_lite_uint32_t,
    ) -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flexa_enable() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flexa_disable() -> vg_lite_error_t;
}
extern "C" {
    pub fn vg_lite_flexa_stop_frame() -> vg_lite_error_t;
}
